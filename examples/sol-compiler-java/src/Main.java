import java_cup.runtime.Symbol;
import java.io.IOException;
import java.io.*;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        String inputFileName = null;
        String outputFileName = null;
        if (args != null) {
            for (int i = 0; i < args.length; i++) {
                if (args[i].equals("-i")) {
                    inputFileName = args[i + 1];
                }
                if (args[i].equals("-o")) {
                    outputFileName = args[i + 1];
                }
            }
        }
        try {
            Compiler compiler = new Compiler();
            compiler.compile( inputFileName, outputFileName );
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

@SuppressWarnings({"rawtypes"})
class parser extends java_cup.runtime.lr_parser {

    public final Class getSymbolContainer() {
        return sym.class;
    }

    /** Default constructor. */
    @Deprecated
    public parser() {super();}

    /** Constructor which sets the default scanner. */
    @Deprecated
    public parser(java_cup.runtime.Scanner s) {super(s);}

    /** Constructor which sets the default scanner. */
    public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

    /** Production table. */
    protected static final short _production_table[][] =
            unpackFromStrings(new String[] {
                    "\000\160\000\002\002\004\000\002\002\004\000\002\003" +
                            "\004\000\002\003\002\000\002\004\003\000\002\004\003" +
                            "\000\002\004\003\000\002\004\003\000\002\005\004\000" +
                            "\002\006\004\000\002\045\003\000\002\045\003\000\002" +
                            "\045\003\000\002\045\003\000\002\045\003\000\002\045" +
                            "\004\000\002\007\010\000\002\007\010\000\002\010\004" +
                            "\000\002\010\002\000\002\011\005\000\002\011\002\000" +
                            "\002\012\011\000\002\013\004\000\002\013\002\000\002" +
                            "\014\005\000\002\014\002\000\002\015\005\000\002\015" +
                            "\002\000\002\016\004\000\002\016\002\000\002\017\004" +
                            "\000\002\017\004\000\002\020\003\000\002\020\003\000" +
                            "\002\020\003\000\002\020\002\000\002\021\007\000\002" +
                            "\022\004\000\002\022\002\000\002\023\010\000\002\023" +
                            "\010\000\002\024\005\000\002\025\004\000\002\025\003" +
                            "\000\002\027\004\000\002\027\002\000\002\030\004\000" +
                            "\002\030\003\000\002\030\003\000\002\030\003\000\002" +
                            "\030\003\000\002\030\003\000\002\030\003\000\002\030" +
                            "\003\000\002\030\003\000\002\031\003\000\002\031\002" +
                            "\000\002\032\010\000\002\033\004\000\002\033\002\000" +
                            "\002\034\007\000\002\035\013\000\002\036\005\000\002" +
                            "\037\004\000\002\040\004\000\002\041\010\000\002\042" +
                            "\005\000\002\042\002\000\002\047\005\000\002\047\003" +
                            "\000\002\047\003\000\002\047\003\000\002\047\003\000" +
                            "\002\047\005\000\002\047\005\000\002\047\005\000\002" +
                            "\047\005\000\002\047\005\000\002\047\005\000\002\047" +
                            "\004\000\002\047\005\000\002\047\005\000\002\047\005" +
                            "\000\002\047\005\000\002\047\005\000\002\047\005\000" +
                            "\002\047\005\000\002\047\005\000\002\047\004\000\002" +
                            "\047\005\000\002\047\005\000\002\047\004\000\002\047" +
                            "\010\000\002\047\006\000\002\047\006\000\002\047\006" +
                            "\000\002\047\006\000\002\046\003\000\002\046\005\000" +
                            "\002\046\006\000\002\051\006\000\002\051\010\000\002" +
                            "\044\004\000\002\044\002\000\002\043\005\000\002\043" +
                            "\002\000\002\050\003\000\002\050\003\000\002\050\003" +
                            "\000\002\050\003\000\002\050\003" });

    /** Access to production table. */
    public short[][] production_table() {return _production_table;}

    /** Parse-action table. */
    protected static final short[][] _action_table =
            unpackFromStrings(new String[] {
                    "\000\345\000\022\024\007\025\017\026\013\027\016\055" +
                            "\014\056\023\057\020\101\021\001\002\000\006\037\075" +
                            "\101\343\001\002\000\024\002\ufffa\024\ufffa\025\ufffa\026" +
                            "\ufffa\027\ufffa\055\ufffa\056\ufffa\057\ufffa\101\ufffa\001\002" +
                            "\000\024\002\ufffd\024\ufffd\025\ufffd\026\ufffd\027\ufffd\055" +
                            "\ufffd\056\ufffd\057\ufffd\101\ufffd\001\002\000\010\037\ufff7" +
                            "\042\ufff7\101\ufff7\001\002\000\024\002\ufffe\024\007\025" +
                            "\017\026\013\027\016\055\014\056\023\057\020\101\021" +
                            "\001\002\000\004\063\337\001\002\000\004\002\336\001" +
                            "\002\000\010\037\ufff5\042\ufff5\101\ufff5\001\002\000\004" +
                            "\101\104\001\002\000\024\002\ufffb\024\ufffb\025\ufffb\026" +
                            "\ufffb\027\ufffb\055\ufffb\056\ufffb\057\ufffb\101\ufffb\001\002" +
                            "\000\010\037\ufff4\042\ufff4\101\ufff4\001\002\000\010\037" +
                            "\ufff6\042\ufff6\101\ufff6\001\002\000\004\101\052\001\002" +
                            "\000\010\037\ufff3\042\ufff3\101\ufff3\001\002\000\024\002" +
                            "\ufffc\024\ufffc\025\ufffc\026\ufffc\027\ufffc\055\ufffc\056\ufffc" +
                            "\057\ufffc\101\ufffc\001\002\000\004\101\024\001\002\000" +
                            "\010\043\uffe9\060\025\061\uffe9\001\002\000\004\101\051" +
                            "\001\002\000\006\043\uffe7\061\030\001\002\000\004\043" +
                            "\036\001\002\000\004\101\031\001\002\000\006\043\uffe5" +
                            "\062\032\001\002\000\004\101\034\001\002\000\004\043" +
                            "\uffe8\001\002\000\006\043\uffe5\062\032\001\002\000\004" +
                            "\043\uffe6\001\002\000\026\024\uffdd\025\uffdd\026\uffdd\027" +
                            "\uffdd\044\uffe3\055\uffdd\064\044\065\037\066\043\101\uffdd" +
                            "\001\002\000\016\024\uffdf\025\uffdf\026\uffdf\027\uffdf\055" +
                            "\uffdf\101\uffdf\001\002\000\026\024\uffdd\025\uffdd\026\uffdd" +
                            "\027\uffdd\044\uffe3\055\uffdd\064\044\065\037\066\043\101" +
                            "\uffdd\001\002\000\016\024\007\025\017\026\013\027\016" +
                            "\055\014\101\021\001\002\000\004\044\045\001\002\000" +
                            "\016\024\uffde\025\uffde\026\uffde\027\uffde\055\uffde\101\uffde" +
                            "\001\002\000\016\024\uffe0\025\uffe0\026\uffe0\027\uffe0\055" +
                            "\uffe0\101\uffe0\001\002\000\024\002\uffeb\024\uffeb\025\uffeb" +
                            "\026\uffeb\027\uffeb\055\uffeb\056\uffeb\057\uffeb\101\uffeb\001" +
                            "\002\000\026\024\uffe2\025\uffe2\026\uffe2\027\uffe2\044\uffe2" +
                            "\055\uffe2\064\uffe2\065\uffe2\066\uffe2\101\uffe2\001\002\000" +
                            "\026\024\uffe1\025\uffe1\026\uffe1\027\uffe1\044\uffe1\055\uffe1" +
                            "\064\uffe1\065\uffe1\066\uffe1\101\uffe1\001\002\000\004\044" +
                            "\uffe4\001\002\000\006\043\uffea\061\uffea\001\002\000\004" +
                            "\043\053\001\002\000\020\024\007\025\017\026\013\027" +
                            "\016\044\uffda\055\056\101\021\001\002\000\006\037\075" +
                            "\101\077\001\002\000\004\044\076\001\002\000\004\101" +
                            "\061\001\002\000\020\024\007\025\017\026\013\027\016" +
                            "\044\uffda\055\056\101\021\001\002\000\004\044\uffdb\001" +
                            "\002\000\004\041\062\001\002\000\016\024\007\025\017" +
                            "\026\013\027\016\042\uffee\101\021\001\002\000\006\037" +
                            "\075\101\074\001\002\000\006\042\uffec\062\070\001\002" +
                            "\000\004\042\066\001\002\000\004\063\067\001\002\000" +
                            "\020\024\uffd8\025\uffd8\026\uffd8\027\uffd8\044\uffd8\055\uffd8" +
                            "\101\uffd8\001\002\000\014\024\007\025\017\026\013\027" +
                            "\016\101\021\001\002\000\004\042\uffef\001\002\000\006" +
                            "\042\uffec\062\070\001\002\000\004\042\uffed\001\002\000" +
                            "\010\042\ufff8\062\ufff8\063\ufff8\001\002\000\010\037\ufff2" +
                            "\042\ufff2\101\ufff2\001\002\000\024\002\uffdc\024\uffdc\025" +
                            "\uffdc\026\uffdc\027\uffdc\055\uffdc\056\uffdc\057\uffdc\101\uffdc" +
                            "\001\002\000\004\041\100\001\002\000\016\024\007\025" +
                            "\017\026\013\027\016\042\uffee\101\021\001\002\000\004" +
                            "\042\102\001\002\000\004\063\103\001\002\000\020\024" +
                            "\uffd9\025\uffd9\026\uffd9\027\uffd9\044\uffd9\055\uffd9\101\uffd9" +
                            "\001\002\000\004\041\105\001\002\000\016\024\007\025" +
                            "\017\026\013\027\016\042\uffee\101\021\001\002\000\004" +
                            "\042\107\001\002\000\004\043\110\001\002\000\102\005" +
                            "\124\022\126\024\007\025\017\026\013\027\016\030\144" +
                            "\031\117\032\156\033\135\034\140\041\146\043\110\044" +
                            "\uffd3\045\127\046\115\047\136\050\130\051\147\052\143" +
                            "\053\150\054\154\063\uffc8\067\132\071\151\072\123\073" +
                            "\134\074\141\075\122\076\162\100\133\101\163\001\002" +
                            "\000\034\002\ufff0\024\ufff0\025\ufff0\026\ufff0\027\ufff0\044" +
                            "\ufff0\055\ufff0\056\ufff0\057\ufff0\064\ufff0\065\ufff0\066\ufff0" +
                            "\101\ufff0\001\002\000\074\005\uffcc\022\uffcc\030\uffcc\031" +
                            "\uffcc\032\uffcc\033\uffcc\034\uffcc\041\uffcc\043\uffcc\044\uffcc" +
                            "\045\uffcc\046\uffcc\047\uffcc\050\uffcc\051\uffcc\052\uffcc\053" +
                            "\uffcc\054\uffcc\063\uffcc\067\uffcc\070\uffcc\071\uffcc\072\uffcc" +
                            "\073\uffcc\074\uffcc\075\uffcc\076\uffcc\100\uffcc\101\uffcc\001" +
                            "\002\000\004\063\335\001\002\000\004\044\uffd5\001\002" +
                            "\000\004\041\333\001\002\000\050\004\uffbb\005\uffbb\006" +
                            "\uffbb\007\uffbb\010\uffbb\012\uffbb\013\uffbb\014\uffbb\015\uffbb" +
                            "\016\uffbb\017\uffbb\020\uffbb\021\uffbb\023\uffbb\035\uffbb\036" +
                            "\uffbb\042\uffbb\062\uffbb\063\uffbb\001\002\000\050\004\uff94" +
                            "\005\uff94\006\uff94\007\uff94\010\uff94\012\uff94\013\uff94\014" +
                            "\uff94\015\uff94\016\uff94\017\uff94\020\uff94\021\uff94\023\uff94" +
                            "\035\uff94\036\uff94\042\uff94\062\uff94\063\uff94\001\002\000" +
                            "\074\005\uffcf\022\uffcf\030\uffcf\031\uffcf\032\uffcf\033\uffcf" +
                            "\034\uffcf\041\uffcf\043\uffcf\044\uffcf\045\uffcf\046\uffcf\047" +
                            "\uffcf\050\uffcf\051\uffcf\052\uffcf\053\uffcf\054\uffcf\063\uffcf" +
                            "\067\uffcf\070\uffcf\071\uffcf\072\uffcf\073\uffcf\074\uffcf\075" +
                            "\uffcf\076\uffcf\100\uffcf\101\uffcf\001\002\000\074\005\uffcb" +
                            "\022\uffcb\030\uffcb\031\uffcb\032\uffcb\033\uffcb\034\uffcb\041" +
                            "\uffcb\043\uffcb\044\uffcb\045\uffcb\046\uffcb\047\uffcb\050\uffcb" +
                            "\051\uffcb\052\uffcb\053\uffcb\054\uffcb\063\uffcb\067\uffcb\070" +
                            "\uffcb\071\uffcb\072\uffcb\073\uffcb\074\uffcb\075\uffcb\076\uffcb" +
                            "\100\uffcb\101\uffcb\001\002\000\004\063\332\001\002\000" +
                            "\004\041\322\001\002\000\046\005\124\022\126\030\144" +
                            "\031\117\032\156\033\135\034\140\041\146\045\127\046" +
                            "\115\047\136\050\130\051\147\052\143\053\150\054\154" +
                            "\100\133\101\165\001\002\000\004\044\320\001\002\000" +
                            "\046\005\124\022\126\030\144\031\117\032\156\033\135" +
                            "\034\140\041\146\045\127\046\115\047\136\050\130\051" +
                            "\147\052\143\053\150\054\154\100\133\101\165\001\002" +
                            "\000\004\041\315\001\002\000\004\041\310\001\002\000" +
                            "\074\005\uffd0\022\uffd0\030\uffd0\031\uffd0\032\uffd0\033\uffd0" +
                            "\034\uffd0\041\uffd0\043\uffd0\044\uffd0\045\uffd0\046\uffd0\047" +
                            "\uffd0\050\uffd0\051\uffd0\052\uffd0\053\uffd0\054\uffd0\063\uffd0" +
                            "\067\uffd0\070\uffd0\071\uffd0\072\uffd0\073\uffd0\074\uffd0\075" +
                            "\uffd0\076\uffd0\100\uffd0\101\uffd0\001\002\000\004\041\301" +
                            "\001\002\000\050\004\uffb9\005\uffb9\006\uffb9\007\uffb9\010" +
                            "\uffb9\012\uffb9\013\uffb9\014\uffb9\015\uffb9\016\uffb9\017\uffb9" +
                            "\020\uffb9\021\uffb9\023\uffb9\035\uffb9\036\uffb9\042\uffb9\062" +
                            "\uffb9\063\uffb9\001\002\000\050\005\124\022\126\030\144" +
                            "\031\117\032\156\033\135\034\140\041\146\045\127\046" +
                            "\115\047\136\050\130\051\147\052\143\053\150\054\154" +
                            "\063\uffc8\100\133\101\165\001\002\000\050\004\uff95\005" +
                            "\uff95\006\uff95\007\uff95\010\uff95\012\uff95\013\uff95\014\uff95" +
                            "\015\uff95\016\uff95\017\uff95\020\uff95\021\uff95\023\uff95\035" +
                            "\uff95\036\uff95\042\uff95\062\uff95\063\uff95\001\002\000\004" +
                            "\101\276\001\002\000\074\005\uffca\022\uffca\030\uffca\031" +
                            "\uffca\032\uffca\033\uffca\034\uffca\041\uffca\043\uffca\044\uffca" +
                            "\045\uffca\046\uffca\047\uffca\050\uffca\051\uffca\052\uffca\053" +
                            "\uffca\054\uffca\063\uffca\067\uffca\070\uffca\071\uffca\072\uffca" +
                            "\073\uffca\074\uffca\075\uffca\076\uffca\100\uffca\101\uffca\001" +
                            "\002\000\050\004\uff92\005\uff92\006\uff92\007\uff92\010\uff92" +
                            "\012\uff92\013\uff92\014\uff92\015\uff92\016\uff92\017\uff92\020" +
                            "\uff92\021\uff92\023\uff92\035\uff92\036\uff92\042\uff92\062\uff92" +
                            "\063\uff92\001\002\000\004\063\275\001\002\000\074\005" +
                            "\uffd1\022\uffd1\030\uffd1\031\uffd1\032\uffd1\033\uffd1\034\uffd1" +
                            "\041\uffd1\043\uffd1\044\uffd1\045\uffd1\046\uffd1\047\uffd1\050" +
                            "\uffd1\051\uffd1\052\uffd1\053\uffd1\054\uffd1\063\uffd1\067\uffd1" +
                            "\070\uffd1\071\uffd1\072\uffd1\073\uffd1\074\uffd1\075\uffd1\076" +
                            "\uffd1\100\uffd1\101\uffd1\001\002\000\004\041\272\001\002" +
                            "\000\050\004\uff96\005\uff96\006\uff96\007\uff96\010\uff96\012" +
                            "\uff96\013\uff96\014\uff96\015\uff96\016\uff96\017\uff96\020\uff96" +
                            "\021\uff96\023\uff96\035\uff96\036\uff96\042\uff96\062\uff96\063" +
                            "\uff96\001\002\000\044\004\202\005\170\006\174\007\173" +
                            "\010\175\012\205\013\200\014\177\015\207\016\201\017" +
                            "\172\020\171\021\210\023\204\035\203\042\uffc9\063\uffc9" +
                            "\001\002\000\046\005\124\022\126\030\144\031\117\032" +
                            "\156\033\135\034\140\041\146\045\127\046\115\047\136" +
                            "\050\130\051\147\052\143\053\150\054\154\100\133\101" +
                            "\165\001\002\000\004\041\265\001\002\000\004\041\262" +
                            "\001\002\000\004\041\256\001\002\000\052\004\uffba\005" +
                            "\uffba\006\uffba\007\uffba\010\uffba\012\uffba\013\uffba\014\uffba" +
                            "\015\uffba\016\uffba\017\uffba\020\uffba\021\uffba\023\uffba\035" +
                            "\uffba\036\uffba\042\uffba\062\uffba\063\uffba\077\254\001\002" +
                            "\000\102\005\124\022\126\024\007\025\017\026\013\027" +
                            "\016\030\144\031\117\032\156\033\135\034\140\041\146" +
                            "\043\110\044\uffd3\045\127\046\115\047\136\050\130\051" +
                            "\147\052\143\053\150\054\154\063\uffc8\067\132\071\151" +
                            "\072\123\073\134\074\141\075\122\076\162\100\133\101" +
                            "\163\001\002\000\004\041\250\001\002\000\072\005\124" +
                            "\022\126\030\144\031\117\032\156\033\135\034\140\041" +
                            "\146\043\110\044\uffd3\045\127\046\115\047\136\050\130" +
                            "\051\147\052\143\053\150\054\154\063\uffc8\067\132\071" +
                            "\151\072\123\073\134\074\141\075\122\076\162\100\133" +
                            "\101\165\001\002\000\050\004\uff93\005\uff93\006\uff93\007" +
                            "\uff93\010\uff93\012\uff93\013\uff93\014\uff93\015\uff93\016\uff93" +
                            "\017\uff93\020\uff93\021\uff93\023\uff93\035\uff93\036\uff93\042" +
                            "\uff93\062\uff93\063\uff93\001\002\000\050\004\uffb8\005\uffb8" +
                            "\006\uffb8\007\uffb8\010\uffb8\012\uffb8\013\uffb8\014\uffb8\015" +
                            "\uffb8\016\uffb8\017\uffb8\020\uffb8\021\uffb8\023\uffb8\035\uffb8" +
                            "\036\uffb8\042\uffb8\062\uffb8\063\uffb8\001\002\000\074\005" +
                            "\uffcd\022\uffcd\030\uffcd\031\uffcd\032\uffcd\033\uffcd\034\uffcd" +
                            "\041\uffcd\043\uffcd\044\uffcd\045\uffcd\046\uffcd\047\uffcd\050" +
                            "\uffcd\051\uffcd\052\uffcd\053\uffcd\054\uffcd\063\uffcd\067\uffcd" +
                            "\070\uffcd\071\uffcd\072\uffcd\073\uffcd\074\uffcd\075\uffcd\076" +
                            "\uffcd\100\uffcd\101\uffcd\001\002\000\074\005\uffce\022\uffce" +
                            "\030\uffce\031\uffce\032\uffce\033\uffce\034\uffce\041\uffce\043" +
                            "\uffce\044\uffce\045\uffce\046\uffce\047\uffce\050\uffce\051\uffce" +
                            "\052\uffce\053\uffce\054\uffce\063\uffce\067\uffce\070\uffce\071" +
                            "\uffce\072\uffce\073\uffce\074\uffce\075\uffce\076\uffce\100\uffce" +
                            "\101\uffce\001\002\000\004\041\237\001\002\000\052\004" +
                            "\uff9f\005\uff9f\006\uff9f\007\uff9f\010\uff9f\012\uff9f\013\uff9f" +
                            "\014\uff9f\015\uff9f\016\uff9f\017\uff9f\020\uff9f\021\uff9f\023" +
                            "\uff9f\035\uff9f\037\ufff3\041\164\063\uff9f\077\uff9f\101\ufff3" +
                            "\001\002\000\050\005\124\022\126\030\144\031\117\032" +
                            "\156\033\135\034\140\041\146\042\uff99\045\127\046\115" +
                            "\047\136\050\130\051\147\052\143\053\150\054\154\100" +
                            "\133\101\165\001\002\000\054\004\uff9f\005\uff9f\006\uff9f" +
                            "\007\uff9f\010\uff9f\012\uff9f\013\uff9f\014\uff9f\015\uff9f\016" +
                            "\uff9f\017\uff9f\020\uff9f\021\uff9f\023\uff9f\035\uff9f\036\uff9f" +
                            "\041\164\042\uff9f\062\uff9f\063\uff9f\077\uff9f\001\002\000" +
                            "\004\042\236\001\002\000\044\004\202\005\170\006\174" +
                            "\007\173\010\175\012\205\013\200\014\177\015\207\016" +
                            "\201\017\172\020\171\021\210\023\204\035\203\042\uff97" +
                            "\062\206\001\002\000\046\005\124\022\126\030\144\031" +
                            "\117\032\156\033\135\034\140\041\146\045\127\046\115" +
                            "\047\136\050\130\051\147\052\143\053\150\054\154\100" +
                            "\133\101\165\001\002\000\046\005\124\022\126\030\144" +
                            "\031\117\032\156\033\135\034\140\041\146\045\127\046" +
                            "\115\047\136\050\130\051\147\052\143\053\150\054\154" +
                            "\100\133\101\165\001\002\000\046\005\124\022\126\030" +
                            "\144\031\117\032\156\033\135\034\140\041\146\045\127" +
                            "\046\115\047\136\050\130\051\147\052\143\053\150\054" +
                            "\154\100\133\101\165\001\002\000\046\005\124\022\126" +
                            "\030\144\031\117\032\156\033\135\034\140\041\146\045" +
                            "\127\046\115\047\136\050\130\051\147\052\143\053\150" +
                            "\054\154\100\133\101\165\001\002\000\046\005\124\022" +
                            "\126\030\144\031\117\032\156\033\135\034\140\041\146" +
                            "\045\127\046\115\047\136\050\130\051\147\052\143\053" +
                            "\150\054\154\100\133\101\165\001\002\000\046\005\124" +
                            "\022\126\030\144\031\117\032\156\033\135\034\140\041" +
                            "\146\045\127\046\115\047\136\050\130\051\147\052\143" +
                            "\053\150\054\154\100\133\101\165\001\002\000\004\042" +
                            "\uff9a\001\002\000\046\005\124\022\126\030\144\031\117" +
                            "\032\156\033\135\034\140\041\146\045\127\046\115\047" +
                            "\136\050\130\051\147\052\143\053\150\054\154\100\133" +
                            "\101\165\001\002\000\046\005\124\022\126\030\144\031" +
                            "\117\032\156\033\135\034\140\041\146\045\127\046\115" +
                            "\047\136\050\130\051\147\052\143\053\150\054\154\100" +
                            "\133\101\165\001\002\000\046\005\124\022\126\030\144" +
                            "\031\117\032\156\033\135\034\140\041\146\045\127\046" +
                            "\115\047\136\050\130\051\147\052\143\053\150\054\154" +
                            "\100\133\101\165\001\002\000\046\005\124\022\126\030" +
                            "\144\031\117\032\156\033\135\034\140\041\146\045\127" +
                            "\046\115\047\136\050\130\051\147\052\143\053\150\054" +
                            "\154\100\133\101\165\001\002\000\046\005\124\022\126" +
                            "\030\144\031\117\032\156\033\135\034\140\041\146\045" +
                            "\127\046\115\047\136\050\130\051\147\052\143\053\150" +
                            "\054\154\100\133\101\165\001\002\000\004\101\216\001" +
                            "\002\000\046\005\124\022\126\030\144\031\117\032\156" +
                            "\033\135\034\140\041\146\045\127\046\115\047\136\050" +
                            "\130\051\147\052\143\053\150\054\154\100\133\101\165" +
                            "\001\002\000\046\005\124\022\126\030\144\031\117\032" +
                            "\156\033\135\034\140\041\146\045\127\046\115\047\136" +
                            "\050\130\051\147\052\143\053\150\054\154\100\133\101" +
                            "\165\001\002\000\046\005\124\022\126\030\144\031\117" +
                            "\032\156\033\135\034\140\041\146\045\127\046\115\047" +
                            "\136\050\130\051\147\052\143\053\150\054\154\100\133" +
                            "\101\165\001\002\000\046\005\124\022\126\030\144\031" +
                            "\117\032\156\033\135\034\140\041\146\045\127\046\115" +
                            "\047\136\050\130\051\147\052\143\053\150\054\154\100" +
                            "\133\101\165\001\002\000\050\004\202\005\170\006\174" +
                            "\007\173\010\175\012\205\013\200\014\177\015\207\016" +
                            "\201\017\172\020\171\021\uffa9\023\204\035\203\036\uffa9" +
                            "\042\uffa9\062\uffa9\063\uffa9\001\002\000\050\004\202\005" +
                            "\170\006\174\007\173\010\175\012\uffad\013\uffad\014\uffad" +
                            "\015\uffad\016\uffad\017\uffad\020\uffad\021\uffad\023\204\035" +
                            "\203\036\uffad\042\uffad\062\uffad\063\uffad\001\002\000\044" +
                            "\004\202\005\170\006\174\007\173\010\175\012\205\013" +
                            "\200\014\177\015\207\016\201\017\172\020\171\021\210" +
                            "\023\204\035\203\042\uff97\062\206\001\002\000\004\042" +
                            "\uff98\001\002\000\050\004\202\005\170\006\174\007\173" +
                            "\010\175\012\uffb0\013\uffb0\014\uffb0\015\uffb0\016\uffb0\017" +
                            "\uffb0\020\uffb0\021\uffb0\023\204\035\203\036\uffb0\042\uffb0" +
                            "\062\uffb0\063\uffb0\001\002\000\054\004\uff9e\005\uff9e\006" +
                            "\uff9e\007\uff9e\010\uff9e\012\uff9e\013\uff9e\014\uff9e\015\uff9e" +
                            "\016\uff9e\017\uff9e\020\uff9e\021\uff9e\023\uff9e\035\uff9e\036" +
                            "\uff9e\041\217\042\uff9e\062\uff9e\063\uff9e\077\uff9e\001\002" +
                            "\000\050\005\124\022\126\030\144\031\117\032\156\033" +
                            "\135\034\140\041\146\042\uff99\045\127\046\115\047\136" +
                            "\050\130\051\147\052\143\053\150\054\154\100\133\101" +
                            "\165\001\002\000\004\042\221\001\002\000\050\004\uff9b" +
                            "\005\uff9b\006\uff9b\007\uff9b\010\uff9b\012\uff9b\013\uff9b\014" +
                            "\uff9b\015\uff9b\016\uff9b\017\uff9b\020\uff9b\021\uff9b\023\uff9b" +
                            "\035\uff9b\036\uff9b\042\uff9b\062\uff9b\063\uff9b\001\002\000" +
                            "\042\004\202\005\170\006\174\007\173\010\175\012\205" +
                            "\013\200\014\177\015\207\016\201\017\172\020\171\021" +
                            "\210\023\204\035\203\036\223\001\002\000\052\004\uff9d" +
                            "\005\uff9d\006\uff9d\007\uff9d\010\uff9d\012\uff9d\013\uff9d\014" +
                            "\uff9d\015\uff9d\016\uff9d\017\uff9d\020\uff9d\021\uff9d\023\uff9d" +
                            "\035\uff9d\036\uff9d\042\uff9d\062\uff9d\063\uff9d\077\uff9d\001" +
                            "\002\000\050\004\uffb6\005\uffb6\006\174\007\173\010\175" +
                            "\012\uffb6\013\uffb6\014\uffb6\015\uffb6\016\uffb6\017\uffb6\020" +
                            "\uffb6\021\uffb6\023\204\035\203\036\uffb6\042\uffb6\062\uffb6" +
                            "\063\uffb6\001\002\000\050\004\202\005\170\006\174\007" +
                            "\173\010\175\012\205\013\200\014\177\015\207\016\uffac" +
                            "\017\uffac\020\uffac\021\uffac\023\204\035\203\036\uffac\042" +
                            "\uffac\062\uffac\063\uffac\001\002\000\050\004\202\005\170" +
                            "\006\174\007\173\010\175\012\uffaf\013\uffaf\014\uffaf\015" +
                            "\uffaf\016\uffaf\017\uffaf\020\uffaf\021\uffaf\023\204\035\203" +
                            "\036\uffaf\042\uffaf\062\uffaf\063\uffaf\001\002\000\050\004" +
                            "\202\005\170\006\174\007\173\010\175\012\uffae\013\uffae" +
                            "\014\uffae\015\uffae\016\uffae\017\uffae\020\uffae\021\uffae\023" +
                            "\204\035\203\036\uffae\042\uffae\062\uffae\063\uffae\001\002" +
                            "\000\050\004\uffb2\005\uffb2\006\uffb2\007\uffb2\010\uffb2\012" +
                            "\uffb2\013\uffb2\014\uffb2\015\uffb2\016\uffb2\017\uffb2\020\uffb2" +
                            "\021\uffb2\023\204\035\203\036\uffb2\042\uffb2\062\uffb2\063" +
                            "\uffb2\001\002\000\050\004\uffb4\005\uffb4\006\uffb4\007\uffb4" +
                            "\010\uffb4\012\uffb4\013\uffb4\014\uffb4\015\uffb4\016\uffb4\017" +
                            "\uffb4\020\uffb4\021\uffb4\023\204\035\203\036\uffb4\042\uffb4" +
                            "\062\uffb4\063\uffb4\001\002\000\050\004\uffb3\005\uffb3\006" +
                            "\uffb3\007\uffb3\010\uffb3\012\uffb3\013\uffb3\014\uffb3\015\uffb3" +
                            "\016\uffb3\017\uffb3\020\uffb3\021\uffb3\023\204\035\203\036" +
                            "\uffb3\042\uffb3\062\uffb3\063\uffb3\001\002\000\050\004\202" +
                            "\005\170\006\174\007\173\010\175\012\205\013\200\014" +
                            "\177\015\207\016\uffab\017\uffab\020\uffab\021\uffab\023\204" +
                            "\035\203\036\uffab\042\uffab\062\uffab\063\uffab\001\002\000" +
                            "\050\004\202\005\170\006\174\007\173\010\175\012\205" +
                            "\013\200\014\177\015\207\016\201\017\172\020\uffaa\021" +
                            "\uffaa\023\204\035\203\036\uffaa\042\uffaa\062\uffaa\063\uffaa" +
                            "\001\002\000\050\004\uffb5\005\uffb5\006\174\007\173\010" +
                            "\175\012\uffb5\013\uffb5\014\uffb5\015\uffb5\016\uffb5\017\uffb5" +
                            "\020\uffb5\021\uffb5\023\204\035\203\036\uffb5\042\uffb5\062" +
                            "\uffb5\063\uffb5\001\002\000\050\004\uff9c\005\uff9c\006\uff9c" +
                            "\007\uff9c\010\uff9c\012\uff9c\013\uff9c\014\uff9c\015\uff9c\016" +
                            "\uff9c\017\uff9c\020\uff9c\021\uff9c\023\uff9c\035\uff9c\036\uff9c" +
                            "\042\uff9c\062\uff9c\063\uff9c\001\002\000\046\005\124\022" +
                            "\126\030\144\031\117\032\156\033\135\034\140\041\146" +
                            "\045\127\046\115\047\136\050\130\051\147\052\143\053" +
                            "\150\054\154\100\133\101\165\001\002\000\044\004\202" +
                            "\005\170\006\174\007\173\010\175\012\205\013\200\014" +
                            "\177\015\207\016\201\017\172\020\171\021\210\023\204" +
                            "\035\203\042\uffbd\062\242\001\002\000\004\042\245\001" +
                            "\002\000\046\005\124\022\126\030\144\031\117\032\156" +
                            "\033\135\034\140\041\146\045\127\046\115\047\136\050" +
                            "\130\051\147\052\143\053\150\054\154\100\133\101\165" +
                            "\001\002\000\044\004\202\005\170\006\174\007\173\010" +
                            "\175\012\205\013\200\014\177\015\207\016\201\017\172" +
                            "\020\171\021\210\023\204\035\203\042\uffbd\062\242\001" +
                            "\002\000\004\042\uffbe\001\002\000\004\063\246\001\002" +
                            "\000\074\005\uffbf\022\uffbf\030\uffbf\031\uffbf\032\uffbf\033" +
                            "\uffbf\034\uffbf\041\uffbf\043\uffbf\044\uffbf\045\uffbf\046\uffbf" +
                            "\047\uffbf\050\uffbf\051\uffbf\052\uffbf\053\uffbf\054\uffbf\063" +
                            "\uffbf\067\uffbf\070\uffbf\071\uffbf\072\uffbf\073\uffbf\074\uffbf" +
                            "\075\uffbf\076\uffbf\100\uffbf\101\uffbf\001\002\000\004\044" +
                            "\uffd4\001\002\000\046\005\124\022\126\030\144\031\117" +
                            "\032\156\033\135\034\140\041\146\045\127\046\115\047" +
                            "\136\050\130\051\147\052\143\053\150\054\154\100\133" +
                            "\101\165\001\002\000\042\004\202\005\170\006\174\007" +
                            "\173\010\175\012\205\013\200\014\177\015\207\016\201" +
                            "\017\172\020\171\021\210\023\204\035\203\042\252\001" +
                            "\002\000\050\004\uffa0\005\uffa0\006\uffa0\007\uffa0\010\uffa0" +
                            "\012\uffa0\013\uffa0\014\uffa0\015\uffa0\016\uffa0\017\uffa0\020" +
                            "\uffa0\021\uffa0\023\uffa0\035\uffa0\036\uffa0\042\uffa0\062\uffa0" +
                            "\063\uffa0\001\002\000\004\044\uffd6\001\002\000\046\005" +
                            "\124\022\126\030\144\031\117\032\156\033\135\034\140" +
                            "\041\146\045\127\046\115\047\136\050\130\051\147\052" +
                            "\143\053\150\054\154\100\133\101\165\001\002\000\050" +
                            "\004\202\005\170\006\174\007\173\010\175\012\205\013" +
                            "\200\014\177\015\207\016\201\017\172\020\171\021\210" +
                            "\023\204\035\203\036\uffbc\042\uffbc\062\uffbc\063\uffbc\001" +
                            "\002\000\046\005\124\022\126\030\144\031\117\032\156" +
                            "\033\135\034\140\041\146\045\127\046\115\047\136\050" +
                            "\130\051\147\052\143\053\150\054\154\100\133\101\165" +
                            "\001\002\000\042\004\202\005\170\006\174\007\173\010" +
                            "\175\012\205\013\200\014\177\015\207\016\201\017\172" +
                            "\020\171\021\210\023\204\035\203\042\260\001\002\000" +
                            "\070\005\124\022\126\030\144\031\117\032\156\033\135" +
                            "\034\140\041\146\043\110\045\127\046\115\047\136\050" +
                            "\130\051\147\052\143\053\150\054\154\063\uffc8\067\132" +
                            "\071\151\072\123\073\134\074\141\075\122\076\162\100" +
                            "\133\101\165\001\002\000\074\005\uffc4\022\uffc4\030\uffc4" +
                            "\031\uffc4\032\uffc4\033\uffc4\034\uffc4\041\uffc4\043\uffc4\044" +
                            "\uffc4\045\uffc4\046\uffc4\047\uffc4\050\uffc4\051\uffc4\052\uffc4" +
                            "\053\uffc4\054\uffc4\063\uffc4\067\uffc4\070\uffc4\071\uffc4\072" +
                            "\uffc4\073\uffc4\074\uffc4\075\uffc4\076\uffc4\100\uffc4\101\uffc4" +
                            "\001\002\000\046\005\124\022\126\030\144\031\117\032" +
                            "\156\033\135\034\140\041\146\045\127\046\115\047\136" +
                            "\050\130\051\147\052\143\053\150\054\154\100\133\101" +
                            "\165\001\002\000\042\004\202\005\170\006\174\007\173" +
                            "\010\175\012\205\013\200\014\177\015\207\016\201\017" +
                            "\172\020\171\021\210\023\204\035\203\042\264\001\002" +
                            "\000\050\004\uffa1\005\uffa1\006\uffa1\007\uffa1\010\uffa1\012" +
                            "\uffa1\013\uffa1\014\uffa1\015\uffa1\016\uffa1\017\uffa1\020\uffa1" +
                            "\021\uffa1\023\uffa1\035\uffa1\036\uffa1\042\uffa1\062\uffa1\063" +
                            "\uffa1\001\002\000\046\005\124\022\126\030\144\031\117" +
                            "\032\156\033\135\034\140\041\146\045\127\046\115\047" +
                            "\136\050\130\051\147\052\143\053\150\054\154\100\133" +
                            "\101\165\001\002\000\042\004\202\005\170\006\174\007" +
                            "\173\010\175\012\205\013\200\014\177\015\207\016\201" +
                            "\017\172\020\171\021\210\023\204\035\203\042\267\001" +
                            "\002\000\050\004\uffa3\005\uffa3\006\uffa3\007\uffa3\010\uffa3" +
                            "\012\uffa3\013\uffa3\014\uffa3\015\uffa3\016\uffa3\017\uffa3\020" +
                            "\uffa3\021\uffa3\023\uffa3\035\uffa3\036\uffa3\042\uffa3\062\uffa3" +
                            "\063\uffa3\001\002\000\042\004\202\005\170\006\174\007" +
                            "\173\010\175\012\205\013\200\014\177\015\207\016\201" +
                            "\017\172\020\171\021\210\023\204\035\203\042\271\001" +
                            "\002\000\050\004\uffb7\005\uffb7\006\uffb7\007\uffb7\010\uffb7" +
                            "\012\uffb7\013\uffb7\014\uffb7\015\uffb7\016\uffb7\017\uffb7\020" +
                            "\uffb7\021\uffb7\023\uffb7\035\uffb7\036\uffb7\042\uffb7\062\uffb7" +
                            "\063\uffb7\001\002\000\046\005\124\022\126\030\144\031" +
                            "\117\032\156\033\135\034\140\041\146\045\127\046\115" +
                            "\047\136\050\130\051\147\052\143\053\150\054\154\100" +
                            "\133\101\165\001\002\000\042\004\202\005\170\006\174" +
                            "\007\173\010\175\012\205\013\200\014\177\015\207\016" +
                            "\201\017\172\020\171\021\210\023\204\035\203\042\274" +
                            "\001\002\000\050\004\uffa2\005\uffa2\006\uffa2\007\uffa2\010" +
                            "\uffa2\012\uffa2\013\uffa2\014\uffa2\015\uffa2\016\uffa2\017\uffa2" +
                            "\020\uffa2\021\uffa2\023\uffa2\035\uffa2\036\uffa2\042\uffa2\062" +
                            "\uffa2\063\uffa2\001\002\000\074\005\uffc1\022\uffc1\030\uffc1" +
                            "\031\uffc1\032\uffc1\033\uffc1\034\uffc1\041\uffc1\043\uffc1\044" +
                            "\uffc1\045\uffc1\046\uffc1\047\uffc1\050\uffc1\051\uffc1\052\uffc1" +
                            "\053\uffc1\054\uffc1\063\uffc1\067\uffc1\070\uffc1\071\uffc1\072" +
                            "\uffc1\073\uffc1\074\uffc1\075\uffc1\076\uffc1\100\uffc1\101\uffc1" +
                            "\001\002\000\050\004\uffa5\005\uffa5\006\uffa5\007\uffa5\010" +
                            "\uffa5\012\uffa5\013\uffa5\014\uffa5\015\uffa5\016\uffa5\017\uffa5" +
                            "\020\uffa5\021\uffa5\023\uffa5\035\uffa5\036\uffa5\042\uffa5\062" +
                            "\uffa5\063\uffa5\001\002\000\004\063\300\001\002\000\074" +
                            "\005\uffc2\022\uffc2\030\uffc2\031\uffc2\032\uffc2\033\uffc2\034" +
                            "\uffc2\041\uffc2\043\uffc2\044\uffc2\045\uffc2\046\uffc2\047\uffc2" +
                            "\050\uffc2\051\uffc2\052\uffc2\053\uffc2\054\uffc2\063\uffc2\067" +
                            "\uffc2\070\uffc2\071\uffc2\072\uffc2\073\uffc2\074\uffc2\075\uffc2" +
                            "\076\uffc2\100\uffc2\101\uffc2\001\002\000\046\005\124\022" +
                            "\126\030\144\031\117\032\156\033\135\034\140\041\146" +
                            "\045\127\046\115\047\136\050\130\051\147\052\143\053" +
                            "\150\054\154\100\133\101\165\001\002\000\042\004\202" +
                            "\005\170\006\174\007\173\010\175\012\205\013\200\014" +
                            "\177\015\207\016\201\017\172\020\171\021\210\023\204" +
                            "\035\203\042\303\001\002\000\070\005\124\022\126\030" +
                            "\144\031\117\032\156\033\135\034\140\041\146\043\110" +
                            "\045\127\046\115\047\136\050\130\051\147\052\143\053" +
                            "\150\054\154\063\uffc8\067\132\071\151\072\123\073\134" +
                            "\074\141\075\122\076\162\100\133\101\165\001\002\000" +
                            "\074\005\uffc5\022\uffc5\030\uffc5\031\uffc5\032\uffc5\033\uffc5" +
                            "\034\uffc5\041\uffc5\043\uffc5\044\uffc5\045\uffc5\046\uffc5\047" +
                            "\uffc5\050\uffc5\051\uffc5\052\uffc5\053\uffc5\054\uffc5\063\uffc5" +
                            "\067\uffc5\070\305\071\uffc5\072\uffc5\073\uffc5\074\uffc5\075" +
                            "\uffc5\076\uffc5\100\uffc5\101\uffc5\001\002\000\070\005\124" +
                            "\022\126\030\144\031\117\032\156\033\135\034\140\041" +
                            "\146\043\110\045\127\046\115\047\136\050\130\051\147" +
                            "\052\143\053\150\054\154\063\uffc8\067\132\071\151\072" +
                            "\123\073\134\074\141\075\122\076\162\100\133\101\165" +
                            "\001\002\000\074\005\uffc7\022\uffc7\030\uffc7\031\uffc7\032" +
                            "\uffc7\033\uffc7\034\uffc7\041\uffc7\043\uffc7\044\uffc7\045\uffc7" +
                            "\046\uffc7\047\uffc7\050\uffc7\051\uffc7\052\uffc7\053\uffc7\054" +
                            "\uffc7\063\uffc7\067\uffc7\070\uffc7\071\uffc7\072\uffc7\073\uffc7" +
                            "\074\uffc7\075\uffc7\076\uffc7\100\uffc7\101\uffc7\001\002\000" +
                            "\074\005\uffc6\022\uffc6\030\uffc6\031\uffc6\032\uffc6\033\uffc6" +
                            "\034\uffc6\041\uffc6\043\uffc6\044\uffc6\045\uffc6\046\uffc6\047" +
                            "\uffc6\050\uffc6\051\uffc6\052\uffc6\053\uffc6\054\uffc6\063\uffc6" +
                            "\067\uffc6\070\uffc6\071\uffc6\072\uffc6\073\uffc6\074\uffc6\075" +
                            "\uffc6\076\uffc6\100\uffc6\101\uffc6\001\002\000\046\005\124" +
                            "\022\126\030\144\031\117\032\156\033\135\034\140\041" +
                            "\146\045\127\046\115\047\136\050\130\051\147\052\143" +
                            "\053\150\054\154\100\133\101\165\001\002\000\042\004" +
                            "\202\005\170\006\174\007\173\010\175\012\205\013\200" +
                            "\014\177\015\207\016\201\017\172\020\171\021\210\023" +
                            "\204\035\203\062\312\001\002\000\014\024\007\025\017" +
                            "\026\013\027\016\101\021\001\002\000\006\037\075\042" +
                            "\314\001\002\000\050\004\uffa4\005\uffa4\006\uffa4\007\uffa4" +
                            "\010\uffa4\012\uffa4\013\uffa4\014\uffa4\015\uffa4\016\uffa4\017" +
                            "\uffa4\020\uffa4\021\uffa4\023\uffa4\035\uffa4\036\uffa4\042\uffa4" +
                            "\062\uffa4\063\uffa4\001\002\000\004\042\316\001\002\000" +
                            "\050\004\uffa7\005\uffa7\006\uffa7\007\uffa7\010\uffa7\012\uffa7" +
                            "\013\uffa7\014\uffa7\015\uffa7\016\uffa7\017\uffa7\020\uffa7\021" +
                            "\uffa7\023\uffa7\035\uffa7\036\uffa7\042\uffa7\062\uffa7\063\uffa7" +
                            "\001\002\000\050\004\uffa8\005\uffa8\006\uffa8\007\uffa8\010" +
                            "\uffa8\012\uffa8\013\uffa8\014\uffa8\015\uffa8\016\uffa8\017\uffa8" +
                            "\020\uffa8\021\uffa8\023\204\035\203\036\uffa8\042\uffa8\062" +
                            "\uffa8\063\uffa8\001\002\000\122\002\uffd7\005\uffd7\022\uffd7" +
                            "\024\uffd7\025\uffd7\026\uffd7\027\uffd7\030\uffd7\031\uffd7\032" +
                            "\uffd7\033\uffd7\034\uffd7\041\uffd7\043\uffd7\044\uffd7\045\uffd7" +
                            "\046\uffd7\047\uffd7\050\uffd7\051\uffd7\052\uffd7\053\uffd7\054" +
                            "\uffd7\055\uffd7\056\uffd7\057\uffd7\063\uffd7\064\uffd7\065\uffd7" +
                            "\066\uffd7\067\uffd7\070\uffd7\071\uffd7\072\uffd7\073\uffd7\074" +
                            "\uffd7\075\uffd7\076\uffd7\100\uffd7\101\uffd7\001\002\000\050" +
                            "\004\uffb1\005\uffb1\006\uffb1\007\uffb1\010\uffb1\012\uffb1\013" +
                            "\uffb1\014\uffb1\015\uffb1\016\uffb1\017\uffb1\020\uffb1\021\uffb1" +
                            "\023\204\035\203\036\uffb1\042\uffb1\062\uffb1\063\uffb1\001" +
                            "\002\000\050\005\124\022\126\030\144\031\117\032\156" +
                            "\033\135\034\140\041\146\045\127\046\115\047\136\050" +
                            "\130\051\147\052\143\053\150\054\154\063\uffc8\100\133" +
                            "\101\165\001\002\000\004\063\324\001\002\000\046\005" +
                            "\124\022\126\030\144\031\117\032\156\033\135\034\140" +
                            "\041\146\045\127\046\115\047\136\050\130\051\147\052" +
                            "\143\053\150\054\154\100\133\101\165\001\002\000\042" +
                            "\004\202\005\170\006\174\007\173\010\175\012\205\013" +
                            "\200\014\177\015\207\016\201\017\172\020\171\021\210" +
                            "\023\204\035\203\063\326\001\002\000\050\005\124\022" +
                            "\126\030\144\031\117\032\156\033\135\034\140\041\146" +
                            "\042\uffc8\045\127\046\115\047\136\050\130\051\147\052" +
                            "\143\053\150\054\154\100\133\101\165\001\002\000\004" +
                            "\042\330\001\002\000\070\005\124\022\126\030\144\031" +
                            "\117\032\156\033\135\034\140\041\146\043\110\045\127" +
                            "\046\115\047\136\050\130\051\147\052\143\053\150\054" +
                            "\154\063\uffc8\067\132\071\151\072\123\073\134\074\141" +
                            "\075\122\076\162\100\133\101\165\001\002\000\074\005" +
                            "\uffc3\022\uffc3\030\uffc3\031\uffc3\032\uffc3\033\uffc3\034\uffc3" +
                            "\041\uffc3\043\uffc3\044\uffc3\045\uffc3\046\uffc3\047\uffc3\050" +
                            "\uffc3\051\uffc3\052\uffc3\053\uffc3\054\uffc3\063\uffc3\067\uffc3" +
                            "\070\uffc3\071\uffc3\072\uffc3\073\uffc3\074\uffc3\075\uffc3\076" +
                            "\uffc3\100\uffc3\101\uffc3\001\002\000\074\005\uffc0\022\uffc0" +
                            "\030\uffc0\031\uffc0\032\uffc0\033\uffc0\034\uffc0\041\uffc0\043" +
                            "\uffc0\044\uffc0\045\uffc0\046\uffc0\047\uffc0\050\uffc0\051\uffc0" +
                            "\052\uffc0\053\uffc0\054\uffc0\063\uffc0\067\uffc0\070\uffc0\071" +
                            "\uffc0\072\uffc0\073\uffc0\074\uffc0\075\uffc0\076\uffc0\100\uffc0" +
                            "\101\uffc0\001\002\000\004\042\334\001\002\000\050\004" +
                            "\uffa6\005\uffa6\006\uffa6\007\uffa6\010\uffa6\012\uffa6\013\uffa6" +
                            "\014\uffa6\015\uffa6\016\uffa6\017\uffa6\020\uffa6\021\uffa6\023" +
                            "\uffa6\035\uffa6\036\uffa6\042\uffa6\062\uffa6\063\uffa6\001\002" +
                            "\000\074\005\uffd2\022\uffd2\030\uffd2\031\uffd2\032\uffd2\033" +
                            "\uffd2\034\uffd2\041\uffd2\043\uffd2\044\uffd2\045\uffd2\046\uffd2" +
                            "\047\uffd2\050\uffd2\051\uffd2\052\uffd2\053\uffd2\054\uffd2\063" +
                            "\uffd2\067\uffd2\070\uffd2\071\uffd2\072\uffd2\073\uffd2\074\uffd2" +
                            "\075\uffd2\076\uffd2\100\uffd2\101\uffd2\001\002\000\004\002" +
                            "\001\001\002\000\120\002\ufff9\005\ufff9\022\ufff9\024\ufff9" +
                            "\025\ufff9\026\ufff9\027\ufff9\030\ufff9\031\ufff9\032\ufff9\033" +
                            "\ufff9\034\ufff9\041\ufff9\043\ufff9\044\ufff9\045\ufff9\046\ufff9" +
                            "\047\ufff9\050\ufff9\051\ufff9\052\ufff9\053\ufff9\054\ufff9\055" +
                            "\ufff9\056\ufff9\057\ufff9\063\ufff9\064\ufff9\065\ufff9\066\ufff9" +
                            "\067\ufff9\071\ufff9\072\ufff9\073\ufff9\074\ufff9\075\ufff9\076" +
                            "\ufff9\100\ufff9\101\ufff9\001\002\000\024\002\ufffe\024\007" +
                            "\025\017\026\013\027\016\055\014\056\023\057\020\101" +
                            "\021\001\002\000\004\002\000\001\002\000\004\002\uffff" +
                            "\001\002\000\006\041\344\063\ufff8\001\002\000\016\024" +
                            "\007\025\017\026\013\027\016\042\uffee\101\021\001\002" +
                            "\000\004\042\346\001\002\000\004\043\110\001\002\000" +
                            "\034\002\ufff1\024\ufff1\025\ufff1\026\ufff1\027\ufff1\044\ufff1" +
                            "\055\ufff1\056\ufff1\057\ufff1\064\ufff1\065\ufff1\066\ufff1\101" +
                            "\ufff1\001\002" });

    /** Access to parse-action table. */
    public short[][] action_table() {return _action_table;}

    /** <code>reduce_goto</code> table. */
    protected static final short[][] _reduce_table =
            unpackFromStrings(new String[] {
                    "\000\345\000\022\002\011\004\007\005\005\006\010\007" +
                            "\021\012\014\021\004\045\003\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\022\003\340\004\337\005\005\006\010\007\021\012\014" +
                            "\021\004\045\003\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
                            "\013\025\001\001\000\002\001\001\000\004\014\026\001" +
                            "\001\000\002\001\001\000\002\001\001\000\004\015\032" +
                            "\001\001\000\002\001\001\000\002\001\001\000\004\015" +
                            "\034\001\001\000\002\001\001\000\010\016\041\017\037" +
                            "\020\040\001\001\000\002\001\001\000\010\016\047\017" +
                            "\037\020\040\001\001\000\012\005\045\006\010\007\046" +
                            "\045\003\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\010\022\054\023\056\045\053\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\010\022" +
                            "\057\023\056\045\053\001\001\000\002\001\001\000\002" +
                            "\001\001\000\010\006\063\010\064\045\062\001\001\000" +
                            "\002\001\001\000\004\011\070\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\006\006\071\045" +
                            "\062\001\001\000\002\001\001\000\004\011\072\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\010\006\063\010\100" +
                            "\045\062\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\010\006\063\010\105" +
                            "\045\062\001\001\000\002\001\001\000\004\024\110\001" +
                            "\001\000\050\005\152\006\010\024\136\025\124\027\113" +
                            "\030\154\031\112\032\141\034\130\035\117\036\111\037" +
                            "\160\040\157\041\120\045\062\046\151\047\144\050\115" +
                            "\051\156\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\012\046\151" +
                            "\047\320\050\115\051\156\001\001\000\002\001\001\000" +
                            "\012\046\151\047\316\050\115\051\156\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\014\031\276\046\151\047\144" +
                            "\050\115\051\156\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\012\046\151\047\267\050\115\051\156" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\050\005\152\006\010\024\136" +
                            "\025\252\027\113\030\154\031\112\032\141\034\130\035" +
                            "\117\036\111\037\160\040\157\041\120\045\062\046\151" +
                            "\047\144\050\115\051\156\001\001\000\002\001\001\000" +
                            "\040\024\136\027\246\030\154\031\112\032\141\034\130" +
                            "\035\117\036\111\037\160\040\157\041\120\046\151\047" +
                            "\144\050\115\051\156\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\014\044\165\046\151\047\166" +
                            "\050\115\051\156\001\001\000\002\001\001\000\002\001" +
                            "\001\000\004\043\175\001\001\000\012\046\151\047\234" +
                            "\050\115\051\156\001\001\000\012\046\151\047\233\050" +
                            "\115\051\156\001\001\000\012\046\151\047\232\050\115" +
                            "\051\156\001\001\000\012\046\151\047\231\050\115\051" +
                            "\156\001\001\000\012\046\151\047\230\050\115\051\156" +
                            "\001\001\000\012\046\151\047\227\050\115\051\156\001" +
                            "\001\000\002\001\001\000\012\046\151\047\226\050\115" +
                            "\051\156\001\001\000\012\046\151\047\225\050\115\051" +
                            "\156\001\001\000\012\046\151\047\224\050\115\051\156" +
                            "\001\001\000\012\046\151\047\223\050\115\051\156\001" +
                            "\001\000\012\046\151\047\221\050\115\051\156\001\001" +
                            "\000\002\001\001\000\012\046\151\047\214\050\115\051" +
                            "\156\001\001\000\012\046\151\047\212\050\115\051\156" +
                            "\001\001\000\012\046\151\047\211\050\115\051\156\001" +
                            "\001\000\012\046\151\047\210\050\115\051\156\001\001" +
                            "\000\002\001\001\000\002\001\001\000\004\043\213\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\014\044\217\046\151\047\166\050\115\051\156\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\012\046\151" +
                            "\047\237\050\115\051\156\001\001\000\004\042\240\001" +
                            "\001\000\002\001\001\000\012\046\151\047\242\050\115" +
                            "\051\156\001\001\000\004\042\243\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\012\046\151\047\250\050\115\051\156\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\012" +
                            "\046\151\047\254\050\115\051\156\001\001\000\002\001" +
                            "\001\000\012\046\151\047\256\050\115\051\156\001\001" +
                            "\000\002\001\001\000\036\024\136\030\260\031\112\032" +
                            "\141\034\130\035\117\036\111\037\160\040\157\041\120" +
                            "\046\151\047\144\050\115\051\156\001\001\000\002\001" +
                            "\001\000\012\046\151\047\262\050\115\051\156\001\001" +
                            "\000\002\001\001\000\002\001\001\000\012\046\151\047" +
                            "\265\050\115\051\156\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\012\046" +
                            "\151\047\272\050\115\051\156\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\012\046\151\047\301" +
                            "\050\115\051\156\001\001\000\002\001\001\000\036\024" +
                            "\136\030\303\031\112\032\141\034\130\035\117\036\111" +
                            "\037\160\040\157\041\120\046\151\047\144\050\115\051" +
                            "\156\001\001\000\004\033\305\001\001\000\036\024\136" +
                            "\030\306\031\112\032\141\034\130\035\117\036\111\037" +
                            "\160\040\157\041\120\046\151\047\144\050\115\051\156" +
                            "\001\001\000\002\001\001\000\002\001\001\000\012\046" +
                            "\151\047\310\050\115\051\156\001\001\000\002\001\001" +
                            "\000\004\045\312\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\014\031\322\046" +
                            "\151\047\144\050\115\051\156\001\001\000\002\001\001" +
                            "\000\012\046\151\047\324\050\115\051\156\001\001\000" +
                            "\002\001\001\000\014\031\326\046\151\047\144\050\115" +
                            "\051\156\001\001\000\002\001\001\000\036\024\136\030" +
                            "\330\031\112\032\141\034\130\035\117\036\111\037\160" +
                            "\040\157\041\120\046\151\047\144\050\115\051\156\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\022\003\341\004\337\005\005\006\010" +
                            "\007\021\012\014\021\004\045\003\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\010\006\063" +
                            "\010\344\045\062\001\001\000\002\001\001\000\004\024" +
                            "\346\001\001\000\002\001\001" });

    /** Access to <code>reduce_goto</code> table. */
    public short[][] reduce_table() {return _reduce_table;}

    /** Instance of action encapsulation class. */
    protected CUP$parser$actions action_obj;

    /** Action encapsulation object initializer. */
    protected void init_actions()
    {
        action_obj = new CUP$parser$actions(this);
    }

    /** Invoke a user supplied parse action. */
    public java_cup.runtime.Symbol do_action(
            int                        act_num,
            java_cup.runtime.lr_parser parser,
            java.util.Stack            stack,
            int                        top)
            throws java.lang.Exception
    {
        /* call code in generated class */
        return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
    }

    /** Indicates start state. */
    public int start_state() {return 0;}
    /** Indicates start production. */
    public int start_production() {return 0;}

    /** <code>EOF</code> Symbol index. */
    public int EOF_sym() {return 0;}

    /** <code>error</code> Symbol index. */
    public int error_sym() {return 1;}



    public static Node root;

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error ");

        if (info instanceof java_cup.runtime.Symbol)
            m.append( "("+info.toString()+")" );

        m.append(" : "+message);

        System.out.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Fatal Syntax Error");
    }


    /** Cup generated class to encapsulate user supplied action code.*/
    @SuppressWarnings({"rawtypes", "unchecked", "unused"})
    class CUP$parser$actions {
        private final parser parser;

        /** Constructor */
        CUP$parser$actions(parser parser) {
            this.parser = parser;
        }

        /** Method 0 with the actual generated action code for actions 0 to 300. */
        public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
                int                        CUP$parser$act_num,
                java_cup.runtime.lr_parser CUP$parser$parser,
                java.util.Stack            CUP$parser$stack,
                int                        CUP$parser$top)
                throws java.lang.Exception
        {
            /* Symbol object for return from actions */
            java_cup.runtime.Symbol CUP$parser$result;

            /* select the action based on the action number */
            switch (CUP$parser$act_num)
            {
                /*. . . . . . . . . . . . . . . . . . . .*/
                case 0: // $START ::= Program EOF
                {
                    Object RESULT =null;
                    int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    RESULT = start_val;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                /* ACCEPT */
                CUP$parser$parser.done_parsing();
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 1: // Program ::= Decl DeclStar
                {
                    Object RESULT =null;
                    int d1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int d1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object d1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int d2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int d2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object d2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Program, ProductionRule.Decl_DeclStar);
                    tmp.getChildren().add((Node) d1);
                    tmp.getChildren().add((Node) d2);
                    tmp.getDefinedVariables().addAll(((Node)d1).getDefinedVariables());
                    tmp.getDefinedVariables().addAll(((Node)d2).getDefinedVariables());

                    tmp.getDefinedFunctions().addAll(((Node)d1).getDefinedFunctions());
                    tmp.getDefinedFunctions().addAll(((Node)d2).getDefinedFunctions());

                    RESULT = tmp; root = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 2: // DeclStar ::= Decl DeclStar
                {
                    Object RESULT =null;
                    int d1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int d1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object d1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int d2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int d2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object d2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.DeclStar, ProductionRule.Decl_DeclStar);
                    tmp.getChildren().add((Node)d1);
                    tmp.getChildren().add((Node)d2);
                    tmp.getDefinedVariables().addAll(((Node)d1).getDefinedVariables());
                    tmp.getDefinedVariables().addAll(((Node)d2).getDefinedVariables());

                    tmp.getDefinedFunctions().addAll(((Node)d1).getDefinedFunctions());
                    tmp.getDefinedFunctions().addAll(((Node)d2).getDefinedFunctions());

                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("DeclStar",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 3: // DeclStar ::=
                {
                    Object RESULT =null;

                    Node tmp = new Node(LeftHand.DeclStar, ProductionRule.EPSILON);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("DeclStar",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 4: // Decl ::= VariableDecl
                {
                    Object RESULT =null;
                    int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object v = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Decl, ProductionRule.VariableDecl);
                    tmp.getChildren().add((Node)v);
                    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Decl",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 5: // Decl ::= FunctionDecl
                {
                    Object RESULT =null;
                    int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Decl, ProductionRule.FunctionDecl);
                    tmp.getChildren().add((Node)f);

                    tmp.getDefinedFunctions().addAll(((Node)f).getDefinedFunctions());

                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Decl",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 6: // Decl ::= ClassDecl
                {
                    Object RESULT =null;
                    int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Decl, ProductionRule.ClassDecl);
                    tmp.getChildren().add((Node)c);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Decl",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 7: // Decl ::= InterfaceDecl
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Decl, ProductionRule.InterfaceDecl);
                    tmp.getChildren().add((Node)i);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Decl",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 8: // VariableDecl ::= Variable SEMICOLON
                {
                    Object RESULT =null;
                    int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object v = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

                    Node tmp = new Node(LeftHand.VariableDecl, ProductionRule.Variable_SEMICOLON);
                    tmp.getChildren().add((Node)v);
                    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("VariableDecl",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 9: // Variable ::= Type IDENTIFIER
                {
                    Object RESULT =null;
                    int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Variable, ProductionRule.Type_IDENTIFIER);
                    tmp.getChildren().add((Node) t);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    Variable variable = new Variable();
                    variable.setName(i);
                    tmp.getDefinedVariables().add(variable);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Variable",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 10: // Type ::= INT
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Type, ProductionRule.INT);
                    Node in = new Node(LeftHand.INT, ProductionRule.TERMINAL);
                    in.setValue(i);
                    tmp.getChildren().add(in);
                    tmp.setTypeName("int");
                    tmp.setArrayDegree(0);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 11: // Type ::= DOUBLE
                {
                    Object RESULT =null;
                    int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String d = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Type, ProductionRule.DOUBLE);
                    Node doub = new Node(LeftHand.DOUBLE, ProductionRule.TERMINAL);
                    doub.setValue(d);
                    tmp.getChildren().add(doub);
                    tmp.setTypeName("double");
                    tmp.setArrayDegree(0);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 12: // Type ::= BOOL
                {
                    Object RESULT =null;
                    int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String b = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Type, ProductionRule.BOOL);
                    Node bo = new Node(LeftHand.BOOL, ProductionRule.TERMINAL);
                    bo.setValue(b);
                    tmp.getChildren().add(bo);
                    tmp.setTypeName("bool");
                    tmp.setArrayDegree(0);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 13: // Type ::= STRING
                {
                    Object RESULT =null;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String s = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Type, ProductionRule.STRING);
                    Node str = new Node(LeftHand.STRING, ProductionRule.TERMINAL);
                    str.setValue(s);
                    tmp.getChildren().add(str);
                    tmp.setTypeName("string");
                    tmp.setArrayDegree(0);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 14: // Type ::= IDENTIFIER
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Type, ProductionRule.IDENTIFIER);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    tmp.setTypeName(i);
                    tmp.setArrayDegree(0);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 15: // Type ::= Type OPENCLOSEBRACKET
                {
                    Object RESULT =null;
                    int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

                    Node tmp = new Node(LeftHand.Type, ProductionRule.Type_OPENCLOSEBRACKET);
                    tmp.getChildren().add((Node)t);
                    tmp.setTypeName(((Node)t).getTypeName());
                    tmp.setArrayDegree(((Node)t).getArrayDegree() + 1);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 16: // FunctionDecl ::= Type IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
                {
                    Object RESULT =null;
                    int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
                    int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
                    Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
                    int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.FunctionDecl, ProductionRule.Type_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_StmtBlock);
                    tmp.getChildren().add((Node)t);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    tmp.getChildren().add((Node) f);
                    tmp.getChildren().add((Node) s);
                    tmp.getDefinedVariables().addAll(((Node)f).getDefinedVariables());

                    Function function = new Function();
                    function.setName(i);
                    function.setParameter(((Node)f).getDefinedVariables());
                    function.setNode(tmp);
                    tmp.getDefinedFunctions().add(function);
                    tmp.setTypeName(((Node)t).getTypeName());
                    tmp.setArrayDegree(((Node)t).getArrayDegree());

                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("FunctionDecl",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 17: // FunctionDecl ::= VOID IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
                    int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.FunctionDecl, ProductionRule.VOID_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_StmtBlock);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    tmp.getChildren().add((Node)f);
                    tmp.getChildren().add((Node)s);
                    tmp.getDefinedVariables().addAll(((Node)f).getDefinedVariables());
                    //tmp.getDefinedVariables().addAll(((Node)s).getDefinedVariables());

                    Function function = new Function();
                    function.setName(i);
                    function.setParameter(((Node)f).getDefinedVariables());
                    function.setNode(tmp);
                    tmp.getDefinedFunctions().add(function);
                    tmp.setTypeName("void");
                    tmp.setArrayDegree(0);

                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("FunctionDecl",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 18: // Formals ::= Variable CommaVariables
                {
                    Object RESULT =null;
                    int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object v = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Formals, ProductionRule.Variable_CommaVariables);
                    tmp.getChildren().add((Node)v);
                    tmp.getChildren().add((Node)c);
                    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
                    tmp.getDefinedVariables().addAll(((Node)c).getDefinedVariables());

                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Formals",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 19: // Formals ::=
                {
                    Object RESULT =null;

                    Node tmp = new Node(LeftHand.Formals, ProductionRule.EPSILON);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Formals",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 20: // CommaVariables ::= COMMA Variable CommaVariables
                {
                    Object RESULT =null;
                    int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object v = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.CommaVariables, ProductionRule.COMMA_Variable_CommaVariables);
                    tmp.getChildren().add((Node)v);
                    tmp.getChildren().add((Node)c);
                    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
                    tmp.getDefinedVariables().addAll(((Node)c).getDefinedVariables());
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("CommaVariables",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 21: // CommaVariables ::=
                {
                    Object RESULT =null;

                    Node tmp = new Node(LeftHand.CommaVariables, ProductionRule.EPSILON);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("CommaVariables",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 22: // ClassDecl ::= CLASS IDENTIFIER ClassDeclExtends ClassDeclImplements OPENCURLYBRACES FieldStar CLOSECURLYBRACES
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
                    int c1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
                    int c1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
                    Object c1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
                    int c2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
                    int c2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
                    Object c2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
                    int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

                    Node tmp = new Node(LeftHand.ClassDecl, ProductionRule.CLASS_IDENTIFIER_ClassDeclExtends_ClassDeclImplements_OPENCURLYBRACES_FieldStar_CLOSECURLYBRACES);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    tmp.getChildren().add((Node)c1);
                    tmp.getChildren().add((Node)c2);
                    tmp.getChildren().add((Node)f);
                    if(((Node)c1).getValue() != null)
                        Type.createPreType(i, (String)((Node)c1).getValue());
                    else
                        Type.createPreType(i, null);
                    tmp.getDefinedVariables().addAll(((Node)f).getDefinedVariables());

                    tmp.getDefinedFunctions().addAll(((Node)f).getDefinedFunctions());

                    Clazz clazz = new Clazz();
                    clazz.setFunctions(tmp.getDefinedFunctions());
                    clazz.setVariables(tmp.getDefinedVariables());
                    clazz.setName(i);

                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ClassDecl",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 23: // ClassDeclExtends ::= EXTENDS IDENTIFIER
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.ClassDeclExtends, ProductionRule.EXTENDS_IDENTIFIER);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    tmp.setValue(i);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ClassDeclExtends",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 24: // ClassDeclExtends ::=
                {
                    Object RESULT =null;

                    Node tmp = new Node(LeftHand.ClassDeclExtends, ProductionRule.EPSILON);
                    tmp.setValue(null);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ClassDeclExtends",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 25: // ClassDeclImplements ::= IMPLEMENTS IDENTIFIER CommaIdentifiers
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.ClassDeclImplements, ProductionRule.IMPLEMENTS_IDENTIFIER_CommaIdentifiers);
                    Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    idNode.setValue(i);
                    tmp.getChildren().add(idNode);
                    tmp.getChildren().add((Node)c);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ClassDeclImplements",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 26: // ClassDeclImplements ::=
                {
                    Object RESULT =null;

                    Node tmp = new Node(LeftHand.ClassDeclImplements, ProductionRule.EPSILON);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ClassDeclImplements",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 27: // CommaIdentifiers ::= COMMA IDENTIFIER CommaIdentifiers
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.CommaIdentifiers, ProductionRule.COMMA_IDENTIFIER_CommaIdentifiers);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    tmp.getChildren().add((Node)c);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("CommaIdentifiers",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 28: // CommaIdentifiers ::=
                {
                    Object RESULT =null;

                    Node tmp = new Node(LeftHand.CommaIdentifiers, ProductionRule.EPSILON);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("CommaIdentifiers",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 29: // FieldStar ::= Field FieldStar
                {
                    Object RESULT =null;
                    int f1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int f1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object f1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int f2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int f2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object f2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.FieldStar, ProductionRule.Field_FieldStar);
                    tmp.getChildren().add((Node)f1);
                    tmp.getChildren().add((Node)f2);
                    tmp.getDefinedVariables().addAll(((Node)f1).getDefinedVariables());
                    tmp.getDefinedVariables().addAll(((Node)f2).getDefinedVariables());

                    tmp.getDefinedFunctions().addAll(((Node)f1).getDefinedFunctions());
                    tmp.getDefinedFunctions().addAll(((Node)f2).getDefinedFunctions());


                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("FieldStar",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 30: // FieldStar ::=
                {
                    Object RESULT =null;

                    Node tmp = new Node(LeftHand.FieldStar, ProductionRule.EPSILON);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("FieldStar",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 31: // Field ::= AccessMode VariableDecl
                {
                    Object RESULT =null;
                    int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object v = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Field, ProductionRule.AccessMode_VariableDecl);
                    tmp.getChildren().add((Node)a);
                    tmp .getChildren().add((Node)v);
                    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
                    for(Variable variable: ((Node)v).getDefinedVariables()){
                        if(((Node)a).getAccessMode() != null)
                            variable.setAccessMode(((Node)a).getAccessMode());
                    }
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Field",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 32: // Field ::= AccessMode FunctionDecl
                {
                    Object RESULT =null;
                    int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                    Node tmp = new Node(LeftHand.Field, ProductionRule.AccessMode_FunctionDecl);
                    tmp.getChildren().add((Node)a);
                    tmp.getChildren().add((Node)f);
                    if(((Node)a).getAccessMode() != null)
                        ((Node)f).getDefinedFunctions().get(0).setAccessMode(((Node)a).getAccessMode());
                    tmp.getDefinedFunctions().addAll(((Node)f).getDefinedFunctions());

                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Field",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 33: // AccessMode ::= PRIVATE
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.AccessMode, ProductionRule.PRIVATE);
                    tmp.setAccessMode(AccessMode.PRIVATE);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("AccessMode",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 34: // AccessMode ::= PROTECTED
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.AccessMode, ProductionRule.PROTECTED);
                    tmp.setAccessMode(AccessMode.PROTECTED);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("AccessMode",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 35: // AccessMode ::= PUBLIC
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.AccessMode, ProductionRule.PUBLIC);
                    tmp.setAccessMode(AccessMode.PUBLIC);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("AccessMode",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 36: // AccessMode ::=
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.AccessMode, ProductionRule.EPSILON);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("AccessMode",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 37: // InterfaceDecl ::= INTERFACE IDENTIFIER OPENCURLYBRACES PrototypeStar CLOSECURLYBRACES
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
                    int psleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int psright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object ps = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.InterfaceDecl, ProductionRule.INTERFACE_IDENTIFIER_OPENCURLYBRACES_PrototypeStar_CLOSECURLYBRACES);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    tmp.getChildren().add((Node) ps);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("InterfaceDecl",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 38: // PrototypeStar ::= Prototype PrototypeStar
                {
                    Object RESULT =null;
                    int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int psleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int psright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object ps = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.PrototypeStar, ProductionRule.Prototype_PrototypeStar);
                    tmp.getChildren().add((Node) p);
                    tmp.getChildren().add((Node) ps);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("PrototypeStar",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 39: // PrototypeStar ::=
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.PrototypeStar, ProductionRule.EPSILON);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("PrototypeStar",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 40: // Prototype ::= Type IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
                {
                    Object RESULT =null;
                    int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
                    int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
                    Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
                    int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    Node tmp = new Node(LeftHand.Prototype, ProductionRule.Type_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_SEMICOLON);
                    tmp.getChildren().add((Node) t);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    tmp.getChildren().add((Node) f);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Prototype",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 41: // Prototype ::= VOID IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
                    String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
                    int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    Node tmp = new Node(LeftHand.Prototype, ProductionRule.VOID_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_SEMICOLON);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(i);
                    tmp.getChildren().add(id);
                    tmp.getChildren().add((Node) f);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Prototype",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 42: // StmtBlock ::= OPENCURLYBRACES InsideStmtBlock CLOSECURLYBRACES
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.StmtBlock, ProductionRule.OPENCURLYBRACES_InsideStmtBlock_CLOSECURLYBRACES);
                    tmp.getChildren().add((Node) i);
                    tmp.getDefinedVariables().addAll(((Node)i).getDefinedVariables());
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("StmtBlock",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 43: // InsideStmtBlock ::= VariableDecl InsideStmtBlock
                {
                    Object RESULT =null;
                    int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object v = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.InsideStmtBlock, ProductionRule.VariableDecl_InsideStmtBlock);
                    tmp.getChildren().add((Node) v);
                    tmp.getChildren().add((Node) i);
                    tmp.getDefinedVariables().addAll(((Node)v).getDefinedVariables());
                    tmp.getDefinedVariables().addAll(((Node)i).getDefinedVariables());

                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("InsideStmtBlock",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 44: // InsideStmtBlock ::= StmtStar
                {
                    Object RESULT =null;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.InsideStmtBlock, ProductionRule.StmtStar);
                    tmp.getChildren().add((Node) s);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("InsideStmtBlock",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 45: // StmtStar ::= Stmt StmtStar
                {
                    Object RESULT =null;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int ssleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int ssright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object ss = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.StmtStar, ProductionRule.Stmt_StmtStar);
                    tmp.getChildren().add((Node) s);
                    tmp.getChildren().add((Node) ss);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("StmtStar",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 46: // StmtStar ::=
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.StmtStar, ProductionRule.EPSILON);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("StmtStar",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 47: // Stmt ::= ExprPrime SEMICOLON
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.Stmt, ProductionRule.ExprPrime_SEMICOLON);
                    tmp.getChildren().add((Node) e);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Stmt",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 48: // Stmt ::= IfStmt
                {
                    Object RESULT =null;
                    int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Stmt, ProductionRule.IfStmt);
                    tmp.getChildren().add((Node) i);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Stmt",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 49: // Stmt ::= WhileStmt
                {
                    Object RESULT =null;
                    int wleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int wright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object w = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Stmt, ProductionRule.WhileStmt);
                    tmp.getChildren().add((Node) w);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Stmt",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 50: // Stmt ::= ForStmt
                {
                    Object RESULT =null;
                    int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Stmt, ProductionRule.ForStmt);
                    tmp.getChildren().add((Node) f);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Stmt",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 51: // Stmt ::= BreakStmt
                {
                    Object RESULT =null;
                    int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Stmt, ProductionRule.BreakStmt);
                    tmp.getChildren().add((Node) b);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Stmt",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 52: // Stmt ::= ContinueStmt
                {
                    Object RESULT =null;
                    int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Stmt, ProductionRule.ContinueStmt);
                    tmp.getChildren().add((Node) c);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Stmt",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 53: // Stmt ::= ReturnStmt
                {
                    Object RESULT =null;
                    int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object r = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Stmt, ProductionRule.ReturnStmt);
                    tmp.getChildren().add((Node) r);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Stmt",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 54: // Stmt ::= PrintStmt
                {
                    Object RESULT =null;
                    int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Stmt, ProductionRule.PrintStmt);
                    tmp.getChildren().add((Node) p);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Stmt",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 55: // Stmt ::= StmtBlock
                {
                    Object RESULT =null;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Stmt, ProductionRule.StmtBlock);
                    tmp.getChildren().add((Node) s);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Stmt",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 56: // ExprPrime ::= Expr
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.ExprPrime, ProductionRule.Expr);
                    tmp.getChildren().add((Node) e);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ExprPrime",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 57: // ExprPrime ::=
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.ExprPrime, ProductionRule.EPSILON);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ExprPrime",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 58: // IfStmt ::= IF OPENPARENTHESIS Expr CLOSEPARENTHESIS Stmt ElsePrime
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int epleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int epright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object ep = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.IfStmt, ProductionRule.IF_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS_Stmt_ElsePrime);
                    tmp.getChildren().add((Node) e);
                    tmp.getChildren().add((Node) s);
                    tmp.getChildren().add((Node) ep);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("IfStmt",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 59: // ElsePrime ::= ELSE Stmt
                {
                    Object RESULT =null;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.ElsePrime, ProductionRule.ELSE_Stmt);
                    tmp.getChildren().add((Node) s);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ElsePrime",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 60: // ElsePrime ::=
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.ElsePrime, ProductionRule.EPSILON);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ElsePrime",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 61: // WhileStmt ::= WHILE OPENPARENTHESIS Expr CLOSEPARENTHESIS Stmt
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.WhileStmt, ProductionRule.WHILE_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS_Stmt);
                    tmp.getChildren().add((Node) e);
                    tmp.getChildren().add((Node) s);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("WhileStmt",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 62: // ForStmt ::= FOR OPENPARENTHESIS ExprPrime SEMICOLON Expr SEMICOLON ExprPrime CLOSEPARENTHESIS Stmt
                {
                    Object RESULT =null;
                    int epleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
                    int epright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
                    Object ep = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
                    int ep1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int ep1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object ep1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.ForStmt, ProductionRule.FOR_OPENPARENTHESIS_ExprPrime_SEMICOLON_Expr_SEMICOLON_ExprPrime_CLOSEPARENTHESIS_Stmt);
                    tmp.getChildren().add((Node) ep);
                    tmp.getChildren().add((Node) e);
                    tmp.getChildren().add((Node) ep1);
                    tmp.getChildren().add((Node) s);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ForStmt",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 63: // ReturnStmt ::= RETURN ExprPrime SEMICOLON
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.ReturnStmt, ProductionRule.RETURN_ExprPrime_SEMICOLON);
                    tmp.getChildren().add((Node) e);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ReturnStmt",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 64: // BreakStmt ::= BREAK SEMICOLON
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.BreakStmt, ProductionRule.BREAK_SEMICOLON);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("BreakStmt",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 65: // ContinueStmt ::= CONTINUE SEMICOLON
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.ContinueStmt, ProductionRule.CONTINUE_SEMICOLON);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ContinueStmt",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 66: // PrintStmt ::= PRINT OPENPARENTHESIS Expr PrintCommaExpr CLOSEPARENTHESIS SEMICOLON
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
                    int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    Node tmp = new Node(LeftHand.PrintStmt, ProductionRule.PRINT_OPENPARENTHESIS_Expr_PrintCommaExpr_CLOSEPARENTHESIS_SEMICOLON);
                    tmp.getChildren().add((Node) e);
                    tmp.getChildren().add((Node) p);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("PrintStmt",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 67: // PrintCommaExpr ::= COMMA Expr PrintCommaExpr
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.PrintCommaExpr, ProductionRule.COMMA_Expr_PrintCommaExpr);
                    tmp.getChildren().add((Node) e);
                    tmp.getChildren().add((Node) p);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("PrintCommaExpr",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 68: // PrintCommaExpr ::=
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.PrintCommaExpr, ProductionRule.EPSILON);
                    RESULT = tmp;
                    CUP$parser$result = parser.getSymbolFactory().newSymbol("PrintCommaExpr",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 69: // Expr ::= LValue ASSIGN Expr
                {
                    Object RESULT =null;
                    int lvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int lvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object lv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.LValue_ASSIGN_Expr);
                    tmp.getChildren().add((Node) lv);
                    tmp.getChildren().add((Node) e);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 70: // Expr ::= Constant
                {
                    Object RESULT =null;
                    int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Constant);
                    tmp.getChildren().add((Node)c);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 71: // Expr ::= LValue
                {
                    Object RESULT =null;
                    int lvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int lvright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object lv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.LValue);
                    tmp.getChildren().add((Node)lv);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 72: // Expr ::= THIS
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.THIS);
                    // todo
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 73: // Expr ::= Call
                {
                    Object RESULT =null;
                    int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Call);
                    tmp.getChildren().add((Node)c);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 74: // Expr ::= OPENPARENTHESIS Expr CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                    tmp.getChildren().add((Node)e);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 75: // Expr ::= Expr PLUS Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_PLUS_Expr);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 76: // Expr ::= Expr MINUS Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_MINUS_Expr);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 77: // Expr ::= Expr MULTIPLY Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_MULTIPLY_Expr);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 78: // Expr ::= Expr DIVIDE Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_DIVIDE_Expr);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 79: // Expr ::= Expr MOD Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_MOD_Expr);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 80: // Expr ::= MINUS Expr
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.MINUS_Expr);
                    tmp.getChildren().add((Node)e);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 81: // Expr ::= Expr LESS Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_LESS_Expr);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 82: // Expr ::= Expr LESSEQUAL Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_LESSEQUAL_Expr);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 83: // Expr ::= Expr GREATER Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_GREATER_Expr);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 84: // Expr ::= Expr GREATEREQUAL Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_GREATEREQUAL_Expr);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 85: // Expr ::= Expr EQUAL Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_EQUAL_Expr);
                    tmp.getChildren().add((Node) e1);
                    tmp.getChildren().add((Node) e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 86: // Expr ::= Expr NOTEQUAL Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_NOTEQUAL_Expr);
                    tmp.getChildren().add((Node) e1);
                    tmp.getChildren().add((Node) e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 87: // Expr ::= Expr AND Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_AND_Expr);
                    tmp.getChildren().add((Node) e1);
                    tmp.getChildren().add((Node) e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 88: // Expr ::= Expr OR Expr
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.Expr_OR_Expr);
                    tmp.getChildren().add((Node) e1);
                    tmp.getChildren().add((Node) e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 89: // Expr ::= NOT Expr
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.NOT_Expr);
                    tmp.getChildren().add((Node) e);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 90: // Expr ::= READINTEGER OPENPARENTHESIS CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.READINTEGER_OPENPARENTHESIS_CLOSEPARENTHESIS);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 91: // Expr ::= READLINE OPENPARENTHESIS CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.READLINE_OPENPARENTHESIS_CLOSEPARENTHESIS);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 92: // Expr ::= NEW IDENTIFIER
                {
                    Object RESULT =null;
                    int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.NEW_IDENTIFIER);
                    Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    idNode.setValue(id);
                    tmp.getChildren().add(idNode);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 93: // Expr ::= NEWARRAY OPENPARENTHESIS Expr COMMA Type CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
                    int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.NEWARRAY_OPENPARENTHESIS_Expr_COMMA_Type_CLOSEPARENTHESIS);
                    tmp.getChildren().add((Node)e);
                    tmp.getChildren().add((Node)t);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 94: // Expr ::= ITOD OPENPARENTHESIS Expr CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.ITOD_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                    tmp.getChildren().add((Node)e);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 95: // Expr ::= DTOI OPENPARENTHESIS Expr CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.DTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                    tmp.getChildren().add((Node)e);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 96: // Expr ::= ITOB OPENPARENTHESIS Expr CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.ITOB_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                    tmp.getChildren().add((Node)e);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 97: // Expr ::= BTOI OPENPARENTHESIS Expr CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.Expr, ProductionRule.BTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS);
                    tmp.getChildren().add((Node)e);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Expr",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 98: // LValue ::= IDENTIFIER
                {
                    Object RESULT =null;
                    int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.LValue, ProductionRule.IDENTIFIER);
                    Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    idNode.setValue(id);
                    tmp.getChildren().add(idNode);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("LValue",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 99: // LValue ::= Expr DOT IDENTIFIER
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
                    int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.LValue, ProductionRule.Expr_DOT_IDENTIFIER);
                    Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    idNode.setValue(id);
                    tmp.getChildren().add((Node)e);
                    tmp.getChildren().add(idNode);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("LValue",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 100: // LValue ::= Expr OPENBRACKET Expr CLOSEBRACKET
                {
                    Object RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
                    Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.LValue, ProductionRule.Expr_OPENBRACKET_Expr_CLOSEBRACKET);
                    tmp.getChildren().add((Node)e1);
                    tmp.getChildren().add((Node)e2);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("LValue",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 101: // Call ::= IDENTIFIER OPENPARENTHESIS Actuals CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    int functionIDleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
                    int functionIDright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
                    String functionID = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
                    int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.Call, ProductionRule.IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS);
                    Node id = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    id.setValue(functionID);
                    tmp.getChildren().add(id);
                    tmp.getChildren().add((Node)a);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Call",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 102: // Call ::= Expr DOT IDENTIFIER OPENPARENTHESIS Actuals CLOSEPARENTHESIS
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
                    int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
                    int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
                    String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
                    int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    Node tmp = new Node(LeftHand.Call, ProductionRule.Expr_DOT_IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS);
                    Node idNode = new Node(LeftHand.IDENTIFIER, ProductionRule.TERMINAL);
                    idNode.setValue(id);
                    tmp.getChildren().add((Node)e);
                    tmp.getChildren().add(idNode);
                    tmp.getChildren().add((Node)a);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Call",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 103: // Actuals ::= Expr ActualsCommaExpr
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Actuals, ProductionRule.Expr_ActualsCommaExpr);
                    tmp.getChildren().add((Node)e);
                    tmp.getChildren().add((Node)a);
                    RESULT = tmp;
                    //todo

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Actuals",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 104: // Actuals ::=
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.Actuals, ProductionRule.EPSILON);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Actuals",34, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 105: // ActualsCommaExpr ::= COMMA Expr ActualsCommaExpr
                {
                    Object RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
                    int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.ActualsCommaExpr, ProductionRule.COMMA_Expr_ActualsCommaExpr);
                    tmp.getChildren().add((Node)e);
                    tmp.getChildren().add((Node)a);
                    RESULT = tmp;
                    //todo

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ActualsCommaExpr",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 106: // ActualsCommaExpr ::=
                {
                    Object RESULT =null;
                    Node tmp = new Node(LeftHand.ActualsCommaExpr, ProductionRule.EPSILON);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("ActualsCommaExpr",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 107: // Constant ::= INTLITERAL
                {
                    Object RESULT =null;
                    int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String d = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Constant, ProductionRule.INTLITERAL);
                    Node id = new Node(LeftHand.INTLITERAL, ProductionRule.TERMINAL);
                    id.setValue(d);
                    tmp.getChildren().add(id);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Constant",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 108: // Constant ::= DOUBLELITERAL
                {
                    Object RESULT =null;
                    int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String f = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Constant, ProductionRule.DOUBLELITERAL);
                    Node id = new Node(LeftHand.DOUBLELITERAL, ProductionRule.TERMINAL);
                    id.setValue(f);
                    tmp.getChildren().add(id);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Constant",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 109: // Constant ::= BOOLEANLITERAL
                {
                    Object RESULT =null;
                    int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String b = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Constant, ProductionRule.BOOLEANLITERAL);
                    Node id = new Node(LeftHand.BOOLEANLITERAL, ProductionRule.TERMINAL);
                    id.setValue(b);
                    tmp.getChildren().add(id);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Constant",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 110: // Constant ::= STRINGLITERAL
                {
                    Object RESULT =null;
                    int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    String s = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Constant, ProductionRule.STRINGLITERAL);
                    Node id = new Node(LeftHand.STRINGLITERAL, ProductionRule.TERMINAL);
                    id.setValue(s);
                    tmp.getChildren().add(id);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Constant",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 111: // Constant ::= NULL
                {
                    Object RESULT =null;
                    int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
                    int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
                    Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                    Node tmp = new Node(LeftHand.Constant, ProductionRule.NULL);
                    Node id = new Node(LeftHand.NULL, ProductionRule.TERMINAL);
                    id.setValue(n);
                    tmp.getChildren().add(id);
                    RESULT = tmp;

                    CUP$parser$result = parser.getSymbolFactory().newSymbol("Constant",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
                }
                return CUP$parser$result;

                /* . . . . . .*/
                default:
                    throw new Exception(
                            "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

            }
        } /* end of method */

        /** Method splitting the generated action code into several parts. */
        public final java_cup.runtime.Symbol CUP$parser$do_action(
                int                        CUP$parser$act_num,
                java_cup.runtime.lr_parser CUP$parser$parser,
                java.util.Stack            CUP$parser$stack,
                int                        CUP$parser$top)
                throws java.lang.Exception
        {
            return CUP$parser$do_action_part00000000(
                    CUP$parser$act_num,
                    CUP$parser$parser,
                    CUP$parser$stack,
                    CUP$parser$top);
        }
    }
}

class Compiler {
    private Node root;
    private int cnt = 0;
    CodeGenerator codeGenerator = new CodeGenerator();
    private static Code finalCode = new Code();
    private static String inputFileName, outputFileName;

    public static void semanticError() {
        finalCode = generateSemanticErrorCode();
        System.out.println(finalCode.getText());
        try {
            writeToFile(Compiler.outputFileName);
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.exit(0);
    }

    private static Code generateSemanticErrorCode(){
        Code code = new Code();
        code.addCode(".text");
        code.addCode(".globl main");
        code.addCode("main:");
        code.addCode("la $a0, errorMsg");
        code.addCode("addi $v0, $zero, 4");
        code.addCode("syscall");
        code.addCode("jr $ra");
        code.addCode(".data");
        code.addCode("errorMsg: .asciiz \"Semantic Error\"");
        return code;
    }

    public static void writeToFile( String outputFileName ) throws IOException {
        //        System.out.println(outputFileName);
//        System.out.println(finalCode.getText());
        FileWriter out = new FileWriter( "out/" +  outputFileName );
        out.write( finalCode.getText());
        out.close();
    }

    public void compile(String inputFileName, String outputFileName) throws Exception {
        Compiler.inputFileName = inputFileName;
        Compiler.outputFileName = outputFileName;
        Reader reader;
        if (inputFileName != null)
            reader = new FileReader("Tests/" + inputFileName);
        else
            reader = new FileReader("tests/t01.in");
        parser p = new parser(new MyScanner(reader));
        p.parse();
        this.setRoot(parser.root);

        // detect semantic errors
        System.out.println("0.ok");

        preProcess(root); // assign indices to parse tree
        System.out.println("1.ok");

        Type.createTypes(); // create all types and construct tree of types
        System.out.println("2.ok");

        createArrays(root); // create arrays and add them to types & set type of each Type node
        System.out.println("3.ok");

//        createBuiltinFunctions(root); // btoi, itob, dtoi, itod
        System.out.println("4.ok");

        areAllVariablesUnique(root); // are there variables with the same name in a scope?
        System.out.println("5.ok");

        areAllFunctionsUnique(root); // are there functions with the same name in a class?
        System.out.println("6.ok");

        setVariableType(root); // set the proper type for each variable
        System.out.println("7.ok");

        setFunctionType(root); // set the proper type for each function
        System.out.println("8.ok");

        setClazzType(); // set the proper type for each class
        System.out.println("9.ok");

        setAllClazzAttributesAndFunctions();
        System.out.println("10.ok");

        setAllNodesType(root); // set the proper type for Constant, Call, Lvalue and Expr
        System.out.println("11.ok");

        checkIntegerIndices(root); // check type of indices and count in NewArray
        System.out.println("12.ok");

        checkFunctionCalls(root);
        System.out.println("13.ok");
        // produce the final code
        checkReturnTypes(root);
        System.out.println("14.ok");

        setFunctionLabels(root);
        System.out.println("15.ok");

        codeGenerator.generateCode(root);
        //todo
        finalCode = codeGenerator.createFinalCode(root);
        writeToFile(outputFileName);
    }

    public void preProcess(Node v) {
        v.setIndex(cnt);
        for (Variable variable : v.getDefinedVariables())
            variable.setNodeIndex(v.getIndex());
        cnt++;
        for (Node node : v.getChildren()) {
            node.setParent(v);
            preProcess(node);
        }
    }

    public void createArrays(Node v) {
        for (Node node : v.getChildren())
            createArrays(node);
        if (v.getLeftHand() == LeftHand.Type && v.getProductionRule() != ProductionRule.Type_OPENCLOSEBRACKET) {
            v.setType(Type.getTypeByName(v.getTypeName(), 0));
        }
        if (v.getLeftHand() == LeftHand.Type && v.getProductionRule() == ProductionRule.Type_OPENCLOSEBRACKET) {
            if (v.getArrayDegree() == 1)
                v.setType(Type.createArrayType(Type.getTypeByName(v.getTypeName(), 0)));
            else
                v.setType(Type.createArrayType(v.getChildren().get(0).getType()));
        }
    }

    private void createBuiltinFunctions(Node root) {
        Function itob = new Function();
        initializeFunction(itob, "itob", "int", "bool");
        Function btoi = new Function();
        initializeFunction(btoi, "btoi", "bool", "int");
        Function dtoi = new Function();
        initializeFunction(dtoi, "dtoi", "double", "int");
        Function itod = new Function();
        initializeFunction(itod, "itod", "int", "double");

        root.getDefinedFunctions().add(itob);
        root.getDefinedFunctions().add(btoi);
        root.getDefinedFunctions().add(dtoi);
        root.getDefinedFunctions().add(itod);
    }

    private void initializeFunction(Function x, String name, String input, String output) {
        Variable tmp = new Variable();
        tmp.setName("x");
        tmp.setType(Type.getTypeByName(input, 0));
        x.getParameter().add(tmp);
        x.setName(name);
        x.setType(Type.getTypeByName(output, 0));
        Label label = new Label(); label.createNewName();
        x.setLabel(label);
    }

    public void areAllVariablesUnique(Node v) {
        ArrayList<Variable> variables = v.getDefinedVariables();
        //System.out.println(v.getLeftHand());
        if (!areArrayListVariablesUnique(variables)) semanticError();
        //System.out.println("ok !");
        for (Node node : v.getChildren())
            areAllVariablesUnique(node);
    }

    public boolean areArrayListVariablesUnique(ArrayList<Variable> variables) {
        for (int i = 0; i < variables.size(); i++) {
            for (int j = i + 1; j < variables.size(); j++) {
                if (variables.get(i).getName().equals(variables.get(j).getName()))
                    return false;
            }
        }
        return true;
    }

    public void areAllFunctionsUnique(Node v) {
        ArrayList<Function> functions = v.getDefinedFunctions();
        if (areArrayListFunctionsUnique(functions) == false) semanticError();

        for (Node node : v.getChildren())
            areAllFunctionsUnique(node);
    }

    public boolean areArrayListFunctionsUnique(ArrayList<Function> functions) {
        for (int i = 0; i < functions.size(); i++) {
            for (int j = i + 1; j < functions.size(); j++) {
                if (functions.get(i).getName().equals(functions.get(j).getName()))
                    return false;
            }
        }
        return true;
    }

    public void setVariableType(Node v) {
        if (v.getLeftHand() == LeftHand.Variable) {
            Type type = Type.getTypeByName((String) v.getChildren().get(0).getTypeName(), v.getChildren().get(0).getArrayDegree());
            if (type == null) Compiler.semanticError();
            v.getDefinedVariables().get(0).setType(type);
        }
        for (Node node : v.getChildren())
            setVariableType(node);
    }

    public void setFunctionType(Node v) {
        if (v.getLeftHand() == LeftHand.FunctionDecl) {
            Function function = v.getDefinedFunctions().get(0);

            Type type = Type.getTypeByName(v.getTypeName(), v.getArrayDegree());
            if (type == null) Compiler.semanticError();
            function.setType(type);
        }
        for (Node node : v.getChildren())
            setFunctionType(node);
    }

    public void setClazzType() {
        for (Clazz clazz : Clazz.getClazzes()) {
            clazz.setType(Type.getTypeByName(clazz.getName(), 0));
        }
    }

    public void setAllClazzAttributesAndFunctions() {
        for (Clazz clazz : Clazz.getClazzes())
            setClazzAttributesAndFunctions(clazz);
    }

    public void setClazzAttributesAndFunctions(Clazz clazz) {
        clazz.setSetAttributesAndFunctions(true);
        Clazz parentClazz = clazz.getParent();
        if (parentClazz == null) return;
        if (parentClazz.isSetAttributesAndFunctions() == false) setClazzAttributesAndFunctions(parentClazz);


        clazz.setFunctions(mergeFunctions(parentClazz.getFunctions(), clazz.getFunctions()));
        clazz.setVariables(mergeVariables(parentClazz.getVariables(), clazz.getVariables()));

    }

    public ArrayList<Function> mergeFunctions(ArrayList<Function> parFunctions, ArrayList<Function> functions) {
        ArrayList<Function> mergedFunctions = new ArrayList<>();
        mergedFunctions.addAll(parFunctions);

        for (Function function : functions) {
            boolean find = false;
            int index = 0;
            for (Function parFunction : parFunctions) {
                if (parFunction.getName().equals(function.getName())) {
                    find = true;
                    if (haveSameSignature(parFunction, function)) {
                        mergedFunctions.set(index, function);
                    } else Compiler.semanticError();
                }
                index++;
            }
            if (find == false) mergedFunctions.add(function);
        }
        return mergedFunctions;
    }

    public boolean haveSameSignature(Function parFunction, Function function) {
        // System.out.println(function.getName());
        // System.out.println("return type signature");
        if (!isConvertibleTo(function.getType(), parFunction.getType())) return false;
        //   System.out.println("ok");
        if (function.getParameter().size() != parFunction.getParameter().size()) return false;
        int index = 0;
        for (Variable variable : function.getParameter()) {
            Variable parVariable = parFunction.getParameter().get(index);
            //       System.out.println("parameters signature");
            //  System.out.println(variable.getName());
            if (!isConvertibleTo(parVariable.getType(), variable.getType())) return false;
            //   System.out.println("ok");
            //     System.out.println("ok");
            index++;
        }
        return true;
    }

    public static boolean isConvertibleTo(Type convertType, Type mainType) {
        //    System.out.println(convertType.getName() + " " + mainType.getName());
        if (mainType.equals(convertType)) return true;
        if (convertType.getArrayDegree() > 0 || mainType.getArrayDegree() > 0)return false;
        while (convertType.getParent() != null) {
            convertType = convertType.getParent();
            if (convertType.equals(mainType)) return true;
        }
        return false;
    }

    public ArrayList<Variable> mergeVariables(ArrayList<Variable> parVariables, ArrayList<Variable> variables) {
        ArrayList<Variable> mergedVariables = new ArrayList<>();
        mergedVariables.addAll(parVariables);
        mergedVariables.addAll(variables);
        if (areArrayListVariablesUnique(mergedVariables) == false) semanticError();
        return mergedVariables;
    }

    // age be terminal bere, type bayad moshakhas shode bashe
    public void setAllNodesType(Node v) {
        for (Node node : v.getChildren())
            setAllNodesType(node);
        switch (v.getLeftHand()) {
            case Constant:
                switch (v.getProductionRule()) {
                    case INTLITERAL:
                        v.setType(Type.getTypeByName("int", 0));
                        break;
                    case DOUBLELITERAL:
                        v.setType(Type.getTypeByName("double", 0));
                        break;
                    case BOOLEANLITERAL:
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case STRINGLITERAL:
                        v.setType(Type.getTypeByName("string", 0));
                        break;
                    case NULL:
                        v.setType(Type.getTypeByName("null", 0));
                        break;
                }
                break;
            case Call:
                //    System.out.println("HI");
                switch (v.getProductionRule()) {
                    case IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS:
                        Function function = findFunction(v, (String) v.getChildren().get(0).getValue());
                        //            System.out.println(function.getName() + " " + function.getType());
                        v.setType(function.getType());
                        break;
                    case Expr_DOT_IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS:
                        Node exprNode = v.getChildren().get(0);
                        Node idNode = v.getChildren().get(1);
                        Node actualsNode = v.getChildren().get(2);

                        Type type = exprNode.getType();
                        if (type.getArrayDegree() > 0 && ((String)idNode.getValue()).equals("length") && actualsNode.getChildren().size() == 0){
                            v.setType(Type.getTypeByName("int", 0));
                        }
                        else{
                            if (type.getArrayDegree() > 0)semanticError();
                            if (((String)idNode.getValue()).equals("length"))semanticError();
                            Clazz clazz = Clazz.getClazzByName(type.getName());
                            //System.out.println(type.getName());
                            if (clazz == null)semanticError();
                            boolean find = false;
                            for (Function classFunction: clazz.getFunctions()){
                                if (classFunction.getName().equals((String) idNode.getValue())){
                                    if (classFunction.getAccessMode() == AccessMode.PUBLIC){
                                        find = true;
                                        v.setType(classFunction.getType());
                                        break;
                                    }
                                    else{
                                        Node findNode = v;
                                        while (findNode.getParent() != null){
                                            findNode = findNode.getParent();
                                            if (findNode.getLeftHand() == LeftHand.ClassDecl){
                                                break;
                                            }
                                        }
                                        if (findNode.getLeftHand() == LeftHand.ClassDecl){
                                            Clazz coverClazz = getClazzNode(findNode);
                                            //System.out.println(coverClazz.getName());
                                            if (classFunction.getAccessMode() == AccessMode.PRIVATE){
                                                if (coverClazz.equals(clazz) && findNode.getDefinedFunctions().contains(classFunction)){
                                                    find = true;
                                                    v.setType(classFunction.getType());
                                                }
                                            }
                                            if (classFunction.getAccessMode() == AccessMode.PROTECTED){
                                                if (isConvertibleTo(coverClazz.getType(), clazz.getType()) || isConvertibleTo(clazz.getType(), coverClazz.getType())){
                                                    find = true;
                                                    v.setType(classFunction.getType());
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (!find)semanticError();
                        }
                        break;
                }
                break;
            case LValue:
                switch (v.getProductionRule()) {
                    case IDENTIFIER:
                        Variable variable = findVariable(v, (String) v.getChildren().get(0).getValue());
                        v.setType(variable.getType());
                        break;
                    case Expr_DOT_IDENTIFIER:

                        Node exprNode = v.getChildren().get(0);
                        Node idNode = v.getChildren().get(1);
                        Type type = exprNode.getType();
//                        System.out.println(idNode.getValue());
                        if (type.getArrayDegree() > 0)semanticError();
                        Clazz clazz = Clazz.getClazzByName(type.getName());
                        if (clazz == null)semanticError();
                        boolean find = false;
                        for (Variable classVariable : clazz.getVariables()){
                            if (classVariable.getName().equals((String)idNode.getValue())){

                                if (classVariable.getAccessMode() == AccessMode.PUBLIC){
                                    find = true;
                                    v.setType(classVariable.getType());
                                    break;
                                }
                                else{
                                    Node findNode = v;
                                    while (findNode.getParent() != null){
                                        findNode = findNode.getParent();
                                        if (findNode.getLeftHand() == LeftHand.ClassDecl){
                                            break;
                                        }
                                    }
                                    if (findNode.getLeftHand() == LeftHand.ClassDecl){
                                        Clazz coverClazz = getClazzNode(findNode);
                                        //System.out.println(coverClazz.getName());
                                        if (classVariable.getAccessMode() == AccessMode.PRIVATE){
                                            if (coverClazz.equals(clazz) && findNode.getDefinedVariables().contains(classVariable)){
                                                find = true;
                                                v.setType(classVariable.getType());
                                            }
                                        }
                                        if (classVariable.getAccessMode() == AccessMode.PROTECTED){
                                            if (isConvertibleTo(coverClazz.getType(), clazz.getType()) || isConvertibleTo(clazz.getType(), coverClazz.getType())){
                                                find = true;
                                                v.setType(classVariable.getType());
                                            }
                                        }
                                    }
                                }

                            }
                        }
//                        System.out.println(idNode.getValue() + " : " + find);
                        if (!find)semanticError();
                        break;
                    case Expr_OPENBRACKET_Expr_CLOSEBRACKET:
                        Type t1 = v.getChildren().get(0).getType();
                        v.setType(Type.getTypeByName(t1.getName(), t1.getArrayDegree() - 1));
                        break;
                }
                break;
            case Expr:
                switch (v.getProductionRule()) {
                    case LValue_ASSIGN_Expr:
                        //System.out.println(v.getChildren().get(0).getType().getName());
                        //System.out.println(v.getChildren().get(1).getType().getName());
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.EQ))
                            semanticError();
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case Constant:
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case LValue:
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case THIS:
                        Node findNode = v;
                        boolean find = false;
                        while (findNode.getParent() != null){
                            findNode = findNode.getParent();
                            if (findNode.getLeftHand() == LeftHand.ClassDecl){
                                find = true;
                                Node idNode = findNode.getChildren().get(0);
                                String className = (String)idNode.getValue();
                                Clazz clazz = Clazz.getClazzByName(className);
                                if (clazz == null) System.out.println("WTF!!!");
                                else v.setType(clazz.getType());
                            }
                        }
                        if (!find)semanticError();
                        break;
                    case Call:
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case Expr_PLUS_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.PLUS))
                            semanticError();
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case Expr_MINUS_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.MINUS))
                            semanticError();
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case Expr_MULTIPLY_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.MULT))
                            semanticError();
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case Expr_DIVIDE_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.DIV))
                            semanticError();
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case Expr_MOD_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.MOD))
                            semanticError();
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case MINUS_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), Operator.SINGLE_MINUS))
                            semanticError();
                        v.setType(v.getChildren().get(0).getType());
                        break;
                    case Expr_LESS_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.LT)) {
                            semanticError();
                        }
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case Expr_LESSEQUAL_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.LTEQ))
                            semanticError();
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case Expr_GREATER_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.GT))
                            semanticError();
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case Expr_GREATEREQUAL_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.GTEQ))
                            semanticError();
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case Expr_EQUAL_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.EQEQ))
                            semanticError();
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case Expr_NOTEQUAL_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.NOTEQ))
                            semanticError();
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case Expr_AND_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.ANDAND))
                            semanticError();
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case Expr_OR_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), v.getChildren().get(1).getType(), Operator.OROR))
                            semanticError();
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case NOT_Expr:
                        if (!Type.possible(v.getChildren().get(0).getType(), Operator.SINGLE_NOT))
                            semanticError();
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                    case READINTEGER_OPENPARENTHESIS_CLOSEPARENTHESIS:
                        v.setType(Type.getTypeByName("int", 0));
                        break;
                    case READLINE_OPENPARENTHESIS_CLOSEPARENTHESIS:
                        v.setType(Type.getTypeByName("string", 0));
                        break;
                    case NEW_IDENTIFIER:
                        Type type = Type.getTypeByName((String)v.getChildren().get(0).getValue(), 0);
                        if (type == null) semanticError();
                        v.setType(type);
                        break;
                    case NEWARRAY_OPENPARENTHESIS_Expr_COMMA_Type_CLOSEPARENTHESIS:
                        v.setType(Type.createArrayType(v.getChildren().get(1).getType()));
                        break;
                    case DTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                        if(!v.getChildren().get(0).getType().equals(Type.getTypeByName("double", 0)))
                            Compiler.semanticError();
                        v.setType(Type.getTypeByName("int", 0));
                        break;
                    case ITOD_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                        if(!v.getChildren().get(0).getType().equals(Type.getTypeByName("int", 0)))
                            Compiler.semanticError();
                        v.setType(Type.getTypeByName("double", 0));
                        break;
                    case BTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                        if(!v.getChildren().get(0).getType().equals(Type.getTypeByName("bool", 0)))
                            Compiler.semanticError();
                        v.setType(Type.getTypeByName("int", 0));
                        break;
                    case ITOB_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                        if(!v.getChildren().get(0).getType().equals(Type.getTypeByName("int", 0)))
                            Compiler.semanticError();
                        v.setType(Type.getTypeByName("bool", 0));
                        break;
                }
                break;
        }
    }

    public static Clazz getClazzNode(Node node){
        Node classIdNode = node.getChildren().get(0);
        String className = (String)classIdNode.getValue();
        Clazz clazz = Clazz.getClazzByName(className);
        return clazz;
    }

    public static Node getNodeClazz(Node node, Clazz clazz){
        if (node.getLeftHand() == LeftHand.ClassDecl){
            Clazz nodeClazz = getClazzNode(node);
            if (clazz.getName().equals(nodeClazz.getName()))
                return node;
        }
        for (Node child : node.getChildren())
            getNodeClazz(child, clazz);
        //    System.out.println("class node not found!");
        semanticError();
        return null;
    }

    public Variable findVariable(Node node, String name) {
        Node node1 = node;
        while (true) {
            //System.out.println(node1.getLeftHand());
            for (Variable variable : node1.getDefinedVariables())
                if (variable.getName().equals(name))
                    return variable;

            if (node1.getLeftHand() == LeftHand.ClassDecl){
                Clazz clazz = getClazzNode(node1);
                //System.out.println(clazz.getName() + " " + clazz.getParent().getName());
                for (Variable variable : clazz.getVariables()){
                    //      System.out.println(variable.getName());
                    if (variable.getName().equals(name)){
                        if (variable.getAccessMode() == AccessMode.PROTECTED || variable.getAccessMode() == AccessMode.PUBLIC){
                            return variable;
                        }
                    }
                }
            }
            if (node1.getParent() == null)
                break;
            else
                node1 = node1.getParent();
        }
        //System.out.println("variable: " + name);
        semanticError();
        return null;
    }

    public Function findFunction(Node node, String name) {
        Node node1 = node;
        while (true) {
            for (Function function : node1.getDefinedFunctions()) {
                if (function.getName().equals(name)) {
                    return function;
                }
            }
            if (node1.getLeftHand() == LeftHand.ClassDecl){
                Clazz clazz = getClazzNode(node1);
                for (Function function : clazz.getFunctions()){
                    if (function.getName().equals(name)){
                        if (function.getAccessMode() == AccessMode.PROTECTED || function.getAccessMode() == AccessMode.PUBLIC)
                            return function;
                    }
                }
            }
            if (node1.getParent() == null) {
                break;
            } else {
                node1 = node1.getParent();
            }
        }
        semanticError();
        return null;
    }

    public void checkIntegerIndices(Node v) {
        if (v.getProductionRule() == ProductionRule.NEWARRAY_OPENPARENTHESIS_Expr_COMMA_Type_CLOSEPARENTHESIS) {
            Type t = v.getChildren().get(0).getType();
            if (!t.equals(Type.getTypeByName("int", 0)))
                semanticError();
        }
        if (v.getProductionRule() == ProductionRule.Expr_OPENBRACKET_Expr_CLOSEBRACKET) {
            Type t = v.getChildren().get(1).getType();
            if (!t.equals(Type.getTypeByName("int", 0)))
                semanticError();
        }
        for (Node node : v.getChildren())
            checkIntegerIndices(node);
    }

    //todo class function calls code
    //todo null

    public void checkFunctionCalls(Node v) {
        for (Node node : v.getChildren()) {
            checkFunctionCalls(node);
        }
        if (v.getLeftHand() == LeftHand.Actuals && v.getProductionRule() == ProductionRule.Expr_ActualsCommaExpr) {
            v.getActualsTypes().add(v.getChildren().get(0).getType());
            v.getActualsTypes().addAll(v.getChildren().get(1).getActualsTypes());
            //System.out.println("+1");
        }
        if (v.getLeftHand() == LeftHand.ActualsCommaExpr && v.getProductionRule() == ProductionRule.COMMA_Expr_ActualsCommaExpr) {
            v.getActualsTypes().add(v.getChildren().get(0).getType());
            v.getActualsTypes().addAll(v.getChildren().get(1).getActualsTypes());
            //System.out.println("+1.1");
        }
        if (v.getLeftHand() == LeftHand.Call) {
            switch (v.getProductionRule()) {
                case IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS:
                    Function function = findFunction(v, (String) v.getChildren().get(0).getValue());


                    if (!areFunctionCallParametersCorrect(function, v.getChildren().get(1).getActualsTypes()))
                        semanticError();
                    break;
                case Expr_DOT_IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS:
                    Node exprNode = v.getChildren().get(0);
                    Node idNode = v.getChildren().get(1);
                    String functionName = (String) idNode.getValue();
                    Node actualsNode = v.getChildren().get(2);
                    Type type = exprNode.getType();
                    if (type.getArrayDegree() > 0 && functionName.equals("length") && actualsNode.getChildren().size() == 0) {
                        return;
                    }
                    if (type.getArrayDegree() > 0) semanticError();
                    Clazz clazz = Clazz.getClazzByName(type.getName());
                    if (clazz == null) semanticError();

                    for (Function classFunction : clazz.getFunctions()) {
                        if (classFunction.getName().equals(functionName)) {
                            if (!areFunctionCallParametersCorrect(classFunction, actualsNode.getActualsTypes()))
                                semanticError();
                            break;
                        }
                    }
            }
        }
    }

    public boolean areFunctionCallParametersCorrect(Function function, ArrayList<Type> parametersTypes) {
        //   System.out.println(function.getName() + " " + function.getParameter().size() + " " + parametersTypes.size());
        if (function.getParameter().size() != parametersTypes.size()) return false;
        int index = 0;
        for (Variable variable : function.getParameter()) {
            //    System.out.println("function call param");
            if (!isConvertibleTo(parametersTypes.get(index), variable.getType()))
                return false;
            //    System.out.println("ok");
            index++;
        }
        return true;
    }


    public void setFunctionLabels(Node node){
        if (node.getLeftHand() == LeftHand.FunctionDecl){
            Function function = node.getDefinedFunctions().get(0);
            Label label = new Label();
            label.createNewName();
            function.setLabel(label);
        }
        for (Node child : node.getChildren()){
            setFunctionLabels(child);
        }
    }

    public void checkReturnTypes(Node node){
        if (node.getLeftHand() == LeftHand.ReturnStmt){
            Node exprNode = node.getChildren().get(0);
            Node findNode = node;
            boolean find = false;
            while(findNode.getParent() != null){
                findNode = findNode.getParent();
                if (findNode.getLeftHand() == LeftHand.FunctionDecl){
                    find = true;
                    Function function = findNode.getDefinedFunctions().get(0);
                    Type returnType = Type.getTypeByName("void", 0);
                    if (exprNode.getChildren().size() > 0)returnType = exprNode.getChildren().get(0).getType();
                    //    System.out.println("check return type with expr return type");
                    if (!isConvertibleTo(returnType, function.getType()))semanticError();
                    //    System.out.println("ok");
                    break;
                }
            }
            if (!find)semanticError();
        }
        for (Node child : node.getChildren())
            checkReturnTypes(child);
    }

    public void debug(Node v) {
        //    System.out.println(v.getLeftHand() + " " + v.getProductionRule());
        Type type = v.getType();
        if (type == null) System.out.println("NULL");
        else System.out.println(type.getName() + " " + type.getParent());
        for (Node node : v.getChildren())
            debug(node);
    }

    public Node getRoot() {
        return root;
    }

    public void setRoot(Node root) {
        this.root = root;
    }

    public Code getFinalCode() {
        return finalCode;
    }

    public void setFinalCode(Code finalCode) {
        this.finalCode = finalCode;
    }
}

class CodeGenerator {
    public ArrayList<Object> floatingPoints = new ArrayList<>();

    public Code createFinalCode(Node root) {
        Code code = new Code();
        code.addCode(root.getCode());
        code.addCode(addFloatingPoints());
        code.addCode(gatherGlobalFunction(root));
        code.addCode(gatherClassCodes(root));
//        System.out.println(code.getText());
        return code;
    }

    private Code addFloatingPoints() {
        Code code = new Code();
        code.addCode("TRUE: .asciiz \"true\"");
        code.addCode("FALSE: .asciiz \"false\"");
        code.addCode("ENDL: .asciiz \"\\n\"");
        code.addCode("buffer: .space 1000");
        return code;
    }

    public Code gatherClassCodes(Node node) {
        Code code = new Code();
        if (node.getLeftHand() == LeftHand.ClassDecl)
            code.addCode(node.getCode());
        for (Node v : node.getChildren()) {
            code.addCode(gatherClassCodes(v));
        }
        return code;
    }

    public Code gatherGlobalFunction(Node node) {
        Code code = new Code();
        for (Function function : node.getDefinedFunctions()) {
            if (function.getName().equals("main")) {
                code.addCode(".text");
                code.addCode(".globl " + function.getLabel().getName());
                code.addCode(function.getNode().getCode());
            }
        }
        for (Function function : node.getDefinedFunctions()) {
            if (!function.getName().equals("main"))
                code.addCode(function.getNode().getCode());
        }
        return code;
    }

    public void btoi(Node node) {
        Code code = new Code();
        generateCode(node.getChildren().get(0));
        code.addCode(node.getChildren().get(0).getCode());
        node.setCode(code);
    }

    public void itod(Node node) {
        Code code = new Code();
        generateCode(node.getChildren().get(0));
        code.addCode(node.getChildren().get(0).getCode());
        code.addCode("mtc1 $t0, $f0");
        code.addCode("cvt.s.w $f0, $f0");
        node.setCode(code);
    }

    public void dtoi(Node node) {
        Code code = new Code();
        generateCode(node.getChildren().get(0));
        code.addCode(node.getChildren().get(0).getCode());
        code.addCode("cvt.w.s $f0, $f0");
        code.addCode("mfc1 $t0, $f0");
        node.setCode(code);
    }

    public void itob(Node node) {
        Code code = new Code();
        generateCode(node.getChildren().get(0));
        code.addCode(node.getChildren().get(0).getCode());
        Label label = new Label();
        Label label1 = new Label();
        label.createNewName();
        label1.createNewName();
        code.addCode("beq $t0, 0, " + label.getName());
        code.addCode("li $t0, 1");
        code.addCode("j " + label1.getName());
        code.addCode(label.getName() + ":");
        code.addCode("li $t0, 0");
        code.addCode(label1.getName() + ":");
        node.setCode(code);
    }

    public void generateCode(Node node) {
        //System.out.println(node.getLeftHand());
        switch (node.getLeftHand()) {
            case Program:
                generateProgramCode(node);
                break;
            case DeclStar:
                generateDeclStarCode(node);
                break;
            case Decl:
                generateDeclCode(node);
                break;
            case FunctionDecl:
                generateFunctionDeclCode(node);
                break;
            case ClassDecl:
                generateClassDeclCode(node);
                break;
            case StmtBlock:
                generateStmtBlockCode(node);
                break;
            case InsideStmtBlock:
                generateInsideStmtBlockCode(node);
                break;
            case StmtStar:
                generateStmtStarCode(node);
                break;
            case Stmt:
                generateStmtCode(node);
                break;
            case ExprPrime:
                generateExprPrimeCode(node);
                break;
            case IfStmt:
                // node.setCode(ifCondition(node));
                generateIfStmt(node);
                break;
            case ElsePrime:
                generateElsePrimeCode(node);
                break;
            case WhileStmt:
                //node.setCode(whileLoop(node));
                generateWhileStmt(node);
                break;
            case ForStmt:
                //node.setCode(forLoop(node));
                generateForStmt(node);
                break;
            case BreakStmt:
                generateBreakCode(node);
                break;
            case ContinueStmt:
                generateContinueCode(node);
                break;
            case ReturnStmt:
                generateReturnCode(node);
                break;
            case PrintStmt:
                generatePrintCode(node, 0);
                break;
            case PrintCommaExpr:
                generatePrintCode(node, 1);
                break;
            case LValue:
                generateLValueCode(node);
                break;
            case Expr:
                generateExprCode(node);
                break;
            case Call:
                generateCallCode(node);
                break;
            case Actuals:
            case ActualsCommaExpr:
                generateActualsCode(node);
                break;
            case Constant:
                generateConstantCode(node);
                break;
            default:
                Code code = new Code();
                node.setCode(code);
                for(Node child : node.getChildren())
                    generateCode(child);
        }
    }

    private void generateDeclCode(Node node) {
        Code code = new Code();
        generateCode(node.getChildren().get(0));
        if (node.getProductionRule() == ProductionRule.FunctionDecl) {
            code.addCode(node.getChildren().get(0).getCode());
        }
        node.setCode(code);
    }

    private void generateDeclStarCode(Node node) {
        Code code = new Code();
        if (node.getChildren().size() > 0) {
            generateCode(node.getChildren().get(0));
            code.addCode(node.getChildren().get(0).getCode());
            generateCode(node.getChildren().get(1));
            code.addCode(node.getChildren().get(1).getCode());
        }
        node.setCode(code);
    }

    public void generateProgramCode(Node node) {
        node.setCode(createGlobalVariables(node.getDefinedVariables()));
        for (Node v : node.getChildren()) {
            generateCode(v);
        }
    }

    private void generateFunctionDeclCode(Node node) {
        Code code = new Code();
        Function function = node.getDefinedFunctions().get(0);
        if (function.getName().equals("main"))
            function.getLabel().setName("main");
        code.addCode(function.getLabel().getName() + " :");
        if (function.getName().equals("main")) {
            code.addCode("move $fp, $sp");
            code.addCode("sub $sp, $sp, 8");
        }
        int index = 3;
        if (node.getProductionRule() == ProductionRule.VOID_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_StmtBlock)
            index = 2;
        generateCode(node.getChildren().get(index));
        code.addCode(node.getChildren().get(index).getCode());
        if (!node.getDefinedFunctions().get(0).getName().equals("main")) {
            code.addCode("sub $sp, $fp, " + (4 * (2 + function.getParameter().size())));
            code.addCode("jr $ra");
        } else{
            code.addCode("li $v0, 10");
            code.addCode("syscall");
        }
        node.setCode(code);
    }

    private void generateClassDeclCode(Node node) {
        for (Node v : node.getChildren())
            generateCode(v);
        Code code = new Code();
        for (Function function : node.getDefinedFunctions())
            code.addCode(function.getNode().getCode());
        node.setCode(code);
    }

    private void generateStmtBlockCode(Node node) {
        Code code = new Code();
        code.addCode("sub $sp, $sp, " + node.getDefinedVariables().size() * 4);
        generateCode(node.getChildren().get(0));
        code.addCode(node.getChildren().get(0).getCode());
        code.addCode("add $sp, $sp, " + node.getDefinedVariables().size() * 4);
        node.setCode(code);
    }

    private void generateInsideStmtBlockCode(Node node) {
        if (node.getProductionRule() == ProductionRule.StmtStar) {
            generateCode(node.getChildren().get(0));
            node.setCode(node.getChildren().get(0).getCode());
        }
        if (node.getProductionRule() == ProductionRule.VariableDecl_InsideStmtBlock) {
            generateCode(node.getChildren().get(1));
            node.setCode(node.getChildren().get(1).getCode());
        }
    }

    private void generateStmtStarCode(Node node) {
        Code code = new Code();
        if (node.getProductionRule() != ProductionRule.EPSILON) {
            generateCode(node.getChildren().get(0));
            generateCode(node.getChildren().get(1));
            code.addCode(node.getChildren().get(0).getCode());
            code.addCode(node.getChildren().get(1).getCode());
        }
        node.setCode(code);
    }

    private void generateStmtCode(Node node) {
        generateCode(node.getChildren().get(0));
        node.setCode(node.getChildren().get(0).getCode());
    }

    private void generateExprPrimeCode(Node node) {
        Code code = new Code();
        if (node.getProductionRule() != ProductionRule.EPSILON) {
            generateCode(node.getChildren().get(0));
            code.addCode(node.getChildren().get(0).getCode());
        }
        node.setCode(code);
    }

    public void generateIfStmt(Node node){
        for (Node node1: node.getChildren()){
            generateCode(node1);
        }
        node.setCode(ifCondition(node));
    }

    public Code ifCondition(Node node) {
        Code code = new Code();
        //code.addCode(node.getChildren().get(0).getCode());
        code.addCode(node.getChildren().get(0).getCode());
        Label label = new Label();
        Label label1 = new Label();
        label.createNewName();
        label1.createNewName();
        code.addCode("beq $t0, 0, " + label1.getName());
        code.addCode(node.getChildren().get(1).getCode());
        code.addCode("j " + label.getName());
        code.addCode(label1.getName() + ":");
        if (node.getChildren().size() == 3) {
            code.addCode(node.getChildren().get(2).getCode());
        }
        code.addCode(label.getName() + ":");
        return code;
    }

    public void generateElsePrimeCode(Node node){
        Code code = new Code();
        if (node.getChildren().size() == 1){
            generateCode(node.getChildren().get(0));
            code.addCode(node.getChildren().get(0).getCode());
        }
        node.setCode(code);
        return;
    }

    public void generateWhileStmt(Node node){
        node.setCode(whileLoop(node));
    }

    public Code whileLoop(Node node) {
        Code code = new Code();
        Label label = new Label();
        Label label1 = new Label();
        label.createNewName();
        label1.createNewName();
        node.getChildren().get(1).setBreakLabel(label1);
        node.getChildren().get(1).setContinueLabel(label);
        for (Node node1: node.getChildren()){
            generateCode(node1);
        }
        code.addCode(label.getName() + ":");
        code.addCode(node.getChildren().get(0).getCode());
        code.addCode("beq $t0, 0, " + label1.getName());
        code.addCode(node.getChildren().get(1).getCode());
        code.addCode("j " + label.getName());
        code.addCode(label1.getName() + ":");
        return code;
    }

    public void generateForStmt(Node node){
        node.setCode(forLoop(node));
    }

    public Code forLoop(Node node) {
        Code code = new Code();
        Label label = new Label();
        label.createNewName();
        Label label1 = new Label();
        label1.createNewName();
        Label label2 = new Label();
        label2.createNewName();
        node.getChildren().get(3).setBreakLabel(label1);
        node.getChildren().get(3).setContinueLabel(label2);
        for (Node node1: node.getChildren()){
            generateCode(node1);
        }
        code.addCode(node.getChildren().get(0).getCode());
        code.addCode(label.getName() + ":");
        code.addCode(node.getChildren().get(1).getCode());
        code.addCode("beq $t0, 0, " + label1.getName());
        code.addCode(node.getChildren().get(3).getCode());
        code.addCode(label2.getName() + ":");
        code.addCode(node.getChildren().get(2).getCode());
        code.addCode("j " + label.getName());
        code.addCode(label1.getName() + ":");
        return code;
    }

    private void generateBreakCode(Node node) {
        node.setCode(Break(node));
    }

    private void generateContinueCode(Node node) {
        node.setCode(Continue(node));
    }

    public void generateReturnCode(Node node) {
        Code code = new Code();
        Node exprNode = node.getChildren().get(0);
        generateCode(exprNode);
        code.addCode(exprNode.getCode());
        //
        Node findNode = node;
        while (findNode.getParent() != null){
            findNode = findNode.getParent();
            if (findNode.getLeftHand() == LeftHand.FunctionDecl){
                Function function = findNode.getDefinedFunctions().get(0);
                code.addCode("sub $sp, $fp, " + (2 + function.getParameter().size()) * 4);
                break;
            }
        }

        if (exprNode.getProductionRule() != ProductionRule.EPSILON) {
            Type returnType = exprNode.getChildren().get(0).getType();
            if (!returnType.equals(Type.getTypeByName("double", 0)))
                code.addCode("move $v0, $t0");
        }
        code.addCode("jr $ra");
        node.setCode(code);
        //todo check kon
    }

    public void generatePrintCode(Node node, int mode) {
        Code code = new Code();
        if (node.getChildren().size() > 0) {
            Node child = node.getChildren().get(0);
            generateCode(child);
            code.addCode(child.getCode());
            if (Type.getTypeByName("bool", 0).equals(node.getChildren().get(0).getType())) {
                Label label = new Label(); label.createNewName();
                Label label2 = new Label(); label2.createNewName();
                code.addCode("beq $t0, 0, " + label.getName());
                code.addCode("la $a0, TRUE");
                code.addCode("j " + label2.getName());
                code.addCode(label.getName() + " :");
                code.addCode("la $a0, FALSE");
                code.addCode(label2.getName() + " :");
                code.addCode("li $v0, 4");
                code.addCode("syscall");
            } else if (Type.getTypeByName("int", 0).equals(node.getChildren().get(0).getType())){
                code.addCode("li $v0, 1");
                code.addCode("move $a0, $t0");
                code.addCode("syscall");
            } else if (Type.getTypeByName("double", 0).equals(node.getChildren().get(0).getType())) {
                code.addCode("li $v0, 2");
                code.addCode("mov.s $f12, $f0");
                code.addCode("syscall");
            } else if (Type.getTypeByName("string", 0).equals(node.getChildren().get(0).getType())) {
                //todo string
                code.addCode("li $v0, 4");
                code.addCode("move $a0, $t0");
                code.addCode("add $a0, $a0, 4");
                code.addCode("syscall");
            }
            generateCode(node.getChildren().get(1));
            code.addCode(node.getChildren().get(1).getCode());
            if(mode == 0) {
                code.addCode("la $a0, ENDL");
                code.addCode("li $v0, 4");
                code.addCode("syscall");
            }
        }
        node.setCode(code);
        return;
    }

    public void generateLValueCode(Node node) {
        switch (node.getProductionRule()) {
            case IDENTIFIER:
                generateLvalueToIdentifierCode(node);
                break;
            case Expr_DOT_IDENTIFIER:
                Code code = new Code();
                Node exprNode = node.getChildren().get(0);
                Node idNode = node.getChildren().get(1);
                generateCode(exprNode);
                code.addCode(exprNode.getCode());
                if (exprNode.getType().getArrayDegree() > 0) Compiler.semanticError();
                Clazz clazz = Clazz.getClazzByName(exprNode.getType().getName());
                if (clazz == null) Compiler.semanticError();
                int offset = getAttributeOffset(clazz, (String) idNode.getValue());
                code.addCode(getClassVariableAddressOutOfClass(offset));
                node.setCode(code);
                break;
            case Expr_OPENBRACKET_Expr_CLOSEBRACKET:
                Node exprNode1 = node.getChildren().get(0);
                Node exprNode2 = node.getChildren().get(1);
                generateCode(exprNode1);
                node.setCode(new Code());
                node.getCode().addCode(exprNode1.getCode());
                node.getCode().addCode("sub $sp, $sp, 4");
                node.getCode().addCode("sw $t0, 0($sp)");
                generateCode(exprNode2);
                node.getCode().addCode(exprNode2.getCode());
                node.getCode().addCode("lw $t1, 0($sp)");
                node.getCode().addCode("add $sp, $sp, 4");
                node.getCode().addCode("add $t0, $t0, 1");
                node.getCode().addCode("mul $t0, $t0, 4");
                node.getCode().addCode("add $t0, $t0, $t1");
        }
    }

    public void generateExprCode(Node node) {
        Code code = new Code();
//        System.out.println(node.getProductionRule());
        switch (node.getProductionRule()) {
            case LValue:
                generateCode(node.getChildren().get(0));
                code.addCode(node.getChildren().get(0).getCode());
                if (node.getType().equals(Type.getTypeByName("double", 0))) {
                    code.addCode(loadDoubleVariable());
                } else {
                    code.addCode(loadIntegerVariable());
                }
                node.setCode(code);
                break;
            case LValue_ASSIGN_Expr:
                node.setCode(assignExprs(node.getChildren().get(0), node.getChildren().get(1)));
                break;
            case Constant:
                generateCode(node.getChildren().get(0));
                node.setCode(node.getChildren().get(0).getCode());
                break;
            case THIS:
                code.addCode("lw $t0, 0($fp)");
                node.setCode(code);
                break;
            case Call:
                generateCode(node.getChildren().get(0));
                node.setCode(node.getChildren().get(0).getCode());
                break;
            case OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                generateCode(node.getChildren().get(0));
                node.setCode(node.getChildren().get(0).getCode());
                break;
            case Expr_PLUS_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.PLUS));
                break;
            case Expr_MINUS_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.MINUS));
                break;
            case Expr_MULTIPLY_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.MULT));
                break;
            case Expr_DIVIDE_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.DIV));
                break;
            case Expr_MOD_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.MOD));
                break;
            case MINUS_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), Operator.SINGLE_MINUS));
                break;
            case Expr_LESS_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.LT));
                break;
            case Expr_LESSEQUAL_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.LTEQ));
                break;
            case Expr_GREATER_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.GT));
                break;
            case Expr_GREATEREQUAL_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.GTEQ));
                break;
            case Expr_EQUAL_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.EQEQ));
                break;
            case Expr_NOTEQUAL_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.NOTEQ));
                break;
            case Expr_AND_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.ANDAND));
                break;
            case Expr_OR_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), node.getChildren().get(1), Operator.OROR));
                break;
            case NOT_Expr:
                node.setCode(calcExpr(node.getChildren().get(0), Operator.SINGLE_NOT));
                break;
            case READINTEGER_OPENPARENTHESIS_CLOSEPARENTHESIS:
                node.setCode(readInteger());
                break;
            case READLINE_OPENPARENTHESIS_CLOSEPARENTHESIS:
                node.setCode(readLine());
                break;
            case NEW_IDENTIFIER:
                node.setCode(newIdentifier(node));
                break;
            case NEWARRAY_OPENPARENTHESIS_Expr_COMMA_Type_CLOSEPARENTHESIS:
                node.setCode(newArray(node));
                break;
            case ITOB_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                itob(node);
                break;
            case BTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                btoi(node);
                break;
            case DTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                dtoi(node);
                break;
            case ITOD_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS:
                itod(node);
                break;
        }
    }

    public Code generateFunctionCallCode(Node actualsNode, Function function){
        Code code = new Code();
        code.addCode("lw $t0, 0($fp)");
        code.addCode("sub $sp, $sp, 4");
        code.addCode("sw $t0, 0($sp)");
        code.addCode(actualsNode.getCode());
        code.addCode("sub $sp, $sp, 8");
        code.addCode("sw $fp, 4($sp)");
        code.addCode("sw $ra, 0($sp)");
        code.addCode("add $fp, $sp, " + (4 * (2 + function.getParameter().size())));
        code.addCode("jal " + function.getLabel().getName());
        if (!function.getType().equals(Type.getTypeByName("double", 0)))
            code.addCode("move $t0, $v0");
        code.addCode("lw $ra, 0($sp)");
        code.addCode("lw $fp, 4($sp)");
        code.addCode("add $sp, $sp, " + (4 * (2 + 1 + function.getParameter().size())));
        return code;
    }

    private void generateCallCode(Node node) {
        Code code = new Code();
        switch (node.getProductionRule()) {
            case IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS:
                Node idNode = node.getChildren().get(0);
                String functionName = (String) idNode.getValue();
                Node actualsNode = node.getChildren().get(1);

                generateCode(actualsNode);

                Node findNode = node;
                while (findNode.getParent() != null) {
                    findNode = findNode.getParent();
                    boolean find = false;
                    for (Function function : findNode.getDefinedFunctions()) {
                        if (function.getName().equals(functionName)) {
                            find = true;
                            node.setCode(generateFunctionCallCode(actualsNode, function));
                            break;
                        }
                    }
                    if (find) break;
                    if (findNode.getLeftHand() == LeftHand.ClassDecl){
                        Node classIdNode = findNode.getChildren().get(0);
                        String className = (String)classIdNode.getValue();
                        Clazz clazz = Clazz.getClazzByName(className);
                        for (Function function : clazz.getFunctions()){
                            if (function.getName().equals(functionName)){
                                if (function.getAccessMode() == AccessMode.PUBLIC || function.getAccessMode() == AccessMode.PROTECTED){
                                    find = true;
                                    node.setCode(generateFunctionCallCode(actualsNode, function));
                                    break;
                                }
                            }
                        }
                    }
                    if (find) break;
                }
                break;
            case Expr_DOT_IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS:
                Node exprNode1 = node.getChildren().get(0);
                generateCode(exprNode1);
                code.addCode(exprNode1.getCode());

                Node idNode1 = node.getChildren().get(1);
                String functionName1 = (String) idNode1.getValue();
                Node actualsNode1 = node.getChildren().get(2);

                if (functionName1.equals("length")) {
                    code.addCode("lw $t0, 0($t0)");
                } else {
                    Type type = exprNode1.getType();
                    Clazz clazz = Clazz.getClazzByName(type.getName());
                    for (Function function : clazz.getFunctions()) {
                        if (function.getName().equals(functionName1)) {
                            code.addCode("sub $sp, $sp, 4");
                            code.addCode("sw $t0, 0($sp)");
                            generateCode(actualsNode1);
                            code.addCode(actualsNode1.getCode());
                            code.addCode("sub $sp, $sp, 8");
                            code.addCode("sw $fp, 4($sp)");
                            code.addCode("sw $ra, 0($sp)");
                            code.addCode("add $fp, $sp, " + (4 * (2 + function.getParameter().size())));
                            code.addCode("jal " + function.getLabel().getName());
                            if (!function.getType().equals(Type.getTypeByName("double", 0)))
                                code.addCode("move $t0, $v0");
                            code.addCode("lw $ra, 0($sp)");
                            code.addCode("lw $fp, 4($sp)");
                            code.addCode("add $sp, $sp, " + (4 * (2 + 1 + function.getParameter().size())));
                            break;
                        }
                    }
                }
                node.setCode(code);

        }
        //todo inheritance nazadim
    }

    public void generateActualsCode(Node node) {
        Code code = new Code();
        if (node.getProductionRule() != ProductionRule.EPSILON) {
            Node exprNode = node.getChildren().get(0);
            generateCode(exprNode);
            code.addCode(exprNode.getCode());
            code.addCode("sub $sp, $sp, 4");
            if (exprNode.getType().equals(Type.getTypeByName("double", 0)))
                code.addCode("s.s $f0, 0($sp)");
            else
                code.addCode("sw $t0, 0($sp)");
            generateCode(node.getChildren().get(1));
            code.addCode(node.getChildren().get(1).getCode());
        }
        node.setCode(code);
    }

    private void generateConstantCode(Node node) {
        Code code = new Code();
        Node childNode = node.getChildren().get(0);
        String str = (String) childNode.getValue();
        switch (node.getProductionRule()) {
            case INTLITERAL:
                code.addCode("li $t0, " + Integer.parseInt(str));
                break;
            case DOUBLELITERAL:
                code.addCode("li.s $f0, " + Double.parseDouble(str));
                break;
            case BOOLEANLITERAL:
                if (str.equals("false")) {
                    code.addCode("li $t0, 0");
                } else code.addCode("li $t0, 1");
                break;
            case STRINGLITERAL:
                str = str.substring(1,str.length() - 1);
                int len = str.length();
                code.addCode("li $v0, 9");
                code.addCode("li $a0, " + (4 + len + 1));
                code.addCode("syscall");
                code.addCode("move $t0, $v0");
                code.addCode("li $t1, " + len);
                code.addCode("sw $t1, 0($t0)");
                for (int i = 0; i < len; i++) {
                    code.addCode("li $t2, " + (int) str.charAt(i));
                    code.addCode("sb $t2 " + (i + 4) + "($t0)");
                }
                code.addCode("li $t2, 0");
                code.addCode("sb $t2, " + (4 + len) + "($t0)");
                break;
            case NULL:
                code.addCode("li $t0, 0");
        }
        node.setCode(code);
    }

    public Code generateLValueToIdentifierCodeForClass(Node findNode, String idName){
        Code code = new Code();
        String className = (String) findNode.getChildren().get(0).getValue();
        Clazz clazz = Clazz.getClazzByName(className);
        if (clazz == null) {
            System.out.println("WTF!");
            Compiler.semanticError();
        } else {
            int offset = getAttributeOffset(clazz, idName);
            code.addCode(getClassVariableAddressInClass(offset));
        }
        return code;
    }

    public Code generateLValueToIdentifierCodeForLocal(Node findNode, int index){
        Code code = new Code();
        Node tempNode = findNode;
        int offset = 4 + index * 4; //this + parameters
        if(findNode.getLeftHand() != LeftHand.FunctionDecl) offset += 8; //$fp and $ra
//        System.out.println();
        while (tempNode.getLeftHand() != LeftHand.FunctionDecl) {
//            System.out.println(tempNode.getLeftHand());

            tempNode = tempNode.getParent();
            if (tempNode.getLeftHand() == LeftHand.StmtBlock || tempNode.getLeftHand() == LeftHand.FunctionDecl) {
                offset += 4 * (tempNode.getDefinedVariables().size());
            }
        }
        code.addCode(getLocalVariableAddress(offset));
        return code;
    }

    public void generateLvalueToIdentifierCode(Node node) {
        String idName = (String) node.getChildren().get(0).getValue();
        Node findNode = node;
        Code code = new Code();
        while (true) {
            int index = 0;
            for (Variable variable : findNode.getDefinedVariables()) {
                if (variable.getName().equals(idName)) {
                    if (findNode.getLeftHand() == LeftHand.Program) {
                        code.addCode(getGlobalVariableAddress(variable));
                        node.setCode(code);
                        return;
                    } else if (findNode.getLeftHand() == LeftHand.ClassDecl) {
                        code.addCode(generateLValueToIdentifierCodeForClass(findNode, idName));
                        node.setCode(code);
                        return;
                    } else if (findNode.getLeftHand() != LeftHand.InsideStmtBlock && findNode.getLeftHand() != LeftHand.FieldStar
                            && findNode.getLeftHand() != LeftHand.DeclStar){
                        //System.out.println(variable.getName() + " " + findNode.getLeftHand());
                        code.addCode(generateLValueToIdentifierCodeForLocal(findNode, index));
                        node.setCode(code);
                        return;
                    }

                }
                index++;
            }
// extends variables
            if (findNode.getLeftHand() == LeftHand.ClassDecl){
                Node idNode = findNode.getChildren().get(0);
                String className = (String)idNode.getValue();
                Clazz clazz = Clazz.getClazzByName(className);

                for (Variable variable : clazz.getVariables()){
                    if (variable.getName().equals(idName)){
                        if (variable.getAccessMode() == AccessMode.PUBLIC || variable.getAccessMode() == AccessMode.PROTECTED){
                            int offset = getAttributeOffset(clazz, idName);
                            code.addCode(getClassVariableAddressInClass(offset));
                            node.setCode(code);
                            return;
                        }
                    }
                }
            }
            findNode = findNode.getParent();
        }
    }

    public int getAttributeOffset(Clazz clazz, String name) {
        int offset = 0;
        for (Variable variable : clazz.getVariables()) {
            if (variable.getName().equals(name)) break;
            offset += 4;
        }
        return offset;
    }

    public Code createGlobalVariables(ArrayList<Variable> globalVariables) {
        Code code = new Code();
        code.addCode(".data");
        for (Variable variable : globalVariables) {
            if (variable.getType().equals(Type.getTypeByName("double", 0)))
                code.addCode(variable.getName() + ":    .float   0.0");
            else
                code.addCode(variable.getName() + ":    .word   0");
        }
        return code;
    }

    public Code getGlobalVariableAddress(Variable variable) {
        Code code = new Code();
        code.addCode("la $t0, " + variable.getName());
        return code;
    }

    public Code loadIntegerVariable() {
        Code code = new Code();
        code.addCode("lw $t0, 0($t0)");
        return code;
    }

    public Code loadDoubleVariable() {
        Code code = new Code();
        code.addCode("l.s $f0, 0($t0)");
        return code;
    }

    public Code readLine() {
        //todo ghalate in
        Code code = new Code();
        Label label = new Label(); label.createNewName();
        Label label1 = new Label(); label1.createNewName();
        Label label2 = new Label(); label2.createNewName();
        Label label3 = new Label(); label3.createNewName();
        code.addCode("li $v0, 8");
        code.addCode("la $a0, buffer");
        code.addCode("li $a1, 1000");
        code.addCode("syscall");
        code.addCode("li $t0, 0");
        code.addCode(label1.getName() + " :");
        code.addCode("lb $t1, 0($a0)");
        code.addCode("beq $t1, 10, " + label.getName());
        code.addCode("add $t0, $t0, 1");
        code.addCode("add $a0, $a0, 1");
        code.addCode("j " + label1.getName());
        code.addCode(label.getName() + " :");
        code.addCode("sb $zero, 0($a0)");
        code.addCode("add $a0, $t0, 5");
        code.addCode("li $v0, 9");
        code.addCode("syscall");
        code.addCode("move $t1, $v0");
        code.addCode("la $a0, buffer");
        code.addCode("sw $t0, 0($t1)");
        code.addCode("add $t1, $t1, 4");
        code.addCode(label2.getName() + " :");
        code.addCode("beq $t0, $zero, " + label3.getName());
        code.addCode("lb $t2, 0($a0)");
        code.addCode("sb $t2, 0($t1)");
        code.addCode("sb $zero, 0($a0)");
        code.addCode("add $a0, $a0, 1");
        code.addCode("add $t1, $t1, 1");
        code.addCode("sub $t0, $t0, 1");
        code.addCode("j " + label2.getName());
        code.addCode(label3.getName() + " :");
        code.addCode("sb $zero, 0($t1)");
        code.addCode("move $t0, $v0");
        return code;
    }

    public Code readInteger() {
        Code code = new Code();
        code.addCode("li $v0, 5");
        code.addCode("syscall");
        code.addCode("move $t0, $v0");
        return code;
    }


    public Code getLocalVariableAddress(int offset) {
        Code code = new Code();
        code.addCode("sub $t0, $fp, " + offset);
        return code;
    }

    public Code getClassVariableAddressInClass(int offset) {
        Code code = new Code();
        code.addCode("lw $t0, 0($fp)");
        code.addCode("add $t0, $t0, " + offset);
        return code;
    }

    public Code getClassVariableAddressOutOfClass(int offset) {
        Code code = new Code();
        code.addCode("add $t0, $t0, " + offset);
        return code;
    }

    public Code calcDotExpr(Node node1, Node node2) {
        Code code = new Code();
        code.addCode(node1.getCode());
        Clazz clazz = Clazz.getClazzByName(node1.getType().getName());
        int offset = 0;
        Type type = Type.getTypeByName("double", 0);
        for (Variable variable : clazz.getVariables()) {
            if (variable.getName().equals(node2.getValue())) {
                type = variable.getType();
                break;
            }
            offset += 4;
        }
        //todo offset ro ba chizi nabayad jam zad?
        code.addCode("add $t0, $t0, " + offset);
        if (!type.equals(Type.getTypeByName("double", 0))) {
            code.addCode("lw $t0, 0($t0)");
        } else {
            code.addCode("l.s $f1, 0($t0)");
        }
        return code;
    }

    public Code calcExpr(Node node, Operator operator) {
        Type t1 = node.getType();
        if (Type.getTypeByName("int", 0).equals(t1) && operator == Operator.SINGLE_MINUS) {
            Code code = new Code();
            generateCode(node);
            code.addCode(node.getCode());
            code.addCode("sub $t0, $zero, $t0");
            return code;
        }
        if (Type.getTypeByName("double", 0).equals(t1) && operator == Operator.SINGLE_MINUS) {
            Code code = new Code();
            generateCode(node);
            code.addCode(node.getCode());
            code.addCode("neg.s $f0, $f0");
            return code;
        }

        if (Type.getTypeByName("bool", 0).equals(t1) && operator == Operator.SINGLE_NOT) {
            Code code = new Code();
//            System.out.println(node.getChildren().get(0).getLeftHand());
            generateCode(node);
            code.addCode(node.getCode());
            code.addCode("xor $t0, $t0, 1");
            return code;
        }
        Compiler.semanticError();
        return null;
    }

    public Code calcObjectExpr(Node node1, Node node2, Operator operator){
        return calcIntExpr(node1, node2, operator);
    }

    public Code calcExpr(Node node1, Node node2, Operator operator) {
        Type t1 = node1.getType();
        Type t2 = node2.getType();

        if (operator == Operator.EQ) {
            return assignExprs(node1, node2);
        }

        if (Type.getTypeByName("int", 0).equals(t1)) {
            return calcIntExpr(node1, node2, operator);
        } else if (Type.getTypeByName("bool", 0).equals(t1)) {
            return calcBooleanExpr(node1, node2, operator);
        } else if (Type.getTypeByName("double", 0).equals(t1)) {
            return calcDoubleExpr(node1, node2, operator);
        } else if (Type.getTypeByName("string", 0).equals(t1)) {
            if (operator == Operator.PLUS)
                return arrayPlusArray(node1, node2, 1);
            if (operator == Operator.EQEQ)
                return compareString(node1, node2);
        } else if (t1.getArrayDegree() > 0) {
            return arrayPlusArray(node1, node2, 4);
        } else {
            return calcObjectExpr(node1, node2, operator);
        }

        Compiler.semanticError();
        return null;
    }

    private Code assignExprs(Node node1, Node node2) {
        Code code = new Code();
        generateCode(node1);
        code.addCode(node1.getCode());
        code.addCode("sub $sp, $sp, 4");
        code.addCode("sw $t0, 0($sp)");
        generateCode(node2);
        code.addCode(node2.getCode());
        code.addCode("lw $t1, 0($sp)");
        code.addCode("add $sp, $sp, 4");
        if (node2.getType().equals(Type.getTypeByName("double", 0)))
            code.addCode("s.s $f0, 0($t1)");
        else
            code.addCode("sw $t0, 0($t1)");
        return code;
    }

    public Code calcIntExpr(Node node1, Node node2, Operator operator) {
        Code code = new Code();
        generateCode(node1);
        code.addCode(node1.getCode());
        code.addCode("sub $sp, $sp, 4");
        code.addCode("sw $t0, 0($sp)");
        generateCode(node2);
        code.addCode(node2.getCode());
        code.addCode("lw $t1, 0($sp)");
        code.addCode("add $sp, $sp, 4");
        switch (operator) {
            case PLUS:
                code.addCode("add $t0, $t1, $t0");
                break;
            case MINUS:
                code.addCode("sub $t0, $t1, $t0");
                break;
            case DIV:
                code.addCode("div $t0, $t1, $t0");
                break;
            case MULT:
                code.addCode("mul $t0, $t1, $t0");
                break;
            case MOD:
                code.addCode("div $t1, $t0");
                code.addCode("mfhi $t0");
                break;
            case LT:
                code.addCode("slt $t0, $t1, $t0");
                break;
            case LTEQ:
                code.addCode("slt $t0, $t0, $t1");
                code.addCode("xor $t0, $t0, 1");
                break;
            case GT:
                code.addCode("slt $t0, $t0, $t1");
                break;
            case GTEQ:
                code.addCode("slt $t0, $t1, $t0");
                code.addCode("xor $t0, $t0, 1");
                break;
            case EQEQ:
                code.addCode("seq $t0, $t1, $t0");
                break;
            case NOTEQ:
                code.addCode("seq $t0, $t1, $t0");
                code.addCode("xor $t0, $t0, 1");
                break;
        }
        return code;
    }

    public Code calcBooleanExpr(Node node1, Node node2, Operator operator) {
        Code code = new Code();
        generateCode(node1);
        code.addCode(node1.getCode());
        code.addCode("sub $sp, $sp, 4");
        code.addCode("sw $t0, 0($sp)");
        generateCode(node2);
        code.addCode(node2.getCode());
        code.addCode("lw $t1, 0($sp)");
        code.addCode("add $sp, $sp, 4");
        switch (operator) {
            case OROR:
                code.addCode("or $t0, $t0, $t1");
                break;
            case ANDAND:
                code.addCode("and $t0, $t0, $t1");
                break;
            case EQEQ:
                code.addCode("seq $t0, $t1, $t0");
                break;
            case NOTEQ:
                code.addCode("seq $t0, $t1, $t0");
                code.addCode("xor $t0, $t0, 1");
                break;
        }
        return code;
    }
    //todo nemidunam ke or bayad bokonim ya na

    public Code calcDoubleExpr(Node node1, Node node2, Operator operator) {
        Code code = new Code();
        generateCode(node1);
        code.addCode(node1.getCode());
        code.addCode("sub $sp, $sp, 4");
        code.addCode("s.s $f0, 0($sp)");
        generateCode(node2);
        code.addCode(node2.getCode());
        code.addCode("l.s $f1, 0($sp)");
        code.addCode("add $sp, $sp, 4");
        switch (operator) {
            case PLUS:
                code.addCode("add.s $f0, $f1, $f0");
                break;
            case MINUS:
                code.addCode("sub.s $f0, $f1, $f0");
                break;
            case MULT:
                code.addCode("mul.s $f0, $f1, $f0");
                break;
            case DIV:
                code.addCode("div.s $f0, $f1, $f0");
                break;
            default:
                if (operator == Operator.LT)
                    code.addCode("c.lt.s $f1, $f0");
                if (operator == Operator.LTEQ)
                    code.addCode("c.le.s $f1, $f0");
                if (operator == Operator.GT)
                    code.addCode("c.gt.s $f1, $f0");
                if (operator == Operator.GTEQ)
                    code.addCode("c.ge.s $f1, $f0");
                if (operator == Operator.EQEQ)
                    code.addCode("c.eq.s $f1, $f0");
                if (operator == Operator.NOTEQ)
                    code.addCode("c.ne.s $f1, $f0");
                code.addCode("li $t0, 0");
                Label label = new Label();
                label.createNewName();
                code.addCode("bclf " + label.getName());
                code.addCode("li $t0, 1");
                code.addCode(label.getName() + " :");
        }
        return code;
    }

    public Code Break(Node node) {
        Code code = new Code();
        Node node1 = node;
        while(node1 != null){
            if (node1.getParent().getLeftHand().equals(LeftHand.ForStmt) || node1.getParent().getLeftHand().equals(LeftHand.WhileStmt)) {
                code.addCode("j " + node1.getBreakLabel().getName());
                break;
            }
            node1 = node1.getParent();
        }
        if (node1 == null){
            Compiler.semanticError();
        }
        return code;
    }

    public Code Continue(Node node) {
        Code code = new Code();
        Node node1 = node;
        while(node1 != null){
            if (node1.getParent().getLeftHand().equals(LeftHand.ForStmt) || node1.getParent().getLeftHand().equals(LeftHand.WhileStmt)) {
                code.addCode("j " + node1.getContinueLabel().getName());
                break;
            }
            node1 = node1.getParent();
        }
        if (node1 == null){
            Compiler.semanticError();
        }
        return code;
    }


    public Code newArray(Node node) {
        Code code = new Code();
        generateCode(node.getChildren().get(0));
        code.addCode(node.getChildren().get(0).getCode());
        //todo age t0 positive nabood chi
        code.addCode("add $t0, $t0, 1");
        code.addCode("move $a0, $t0");
        code.addCode("mul $a0, $a0, 4");
        code.addCode("li $v0, 9");
        code.addCode("syscall");
        code.addCode("sub $t0, $t0, 1");
        code.addCode("sw $t0, 0($v0)");
        code.addCode("move $t0, $v0");
        return code;
    }

    private Code newIdentifier(Node node) {
        Code code = new Code();
        String name = (String) node.getChildren().get(0).getValue();
        int numberOfVariables = Clazz.getClazzByName(name).getVariables().size();
        code.addCode("li $a0, " + (1 + numberOfVariables) * 4);
        code.addCode("li $v0, 9");
        code.addCode("syscall");
        code.addCode("move $t0, $v0");
        return code;
    }

    public Code ExprOpenBracketExprCloseBracket(Node node) {
        Code code = new Code();
        code.addCode(node.getChildren().get(0).getCode());
        code.addCode("sub $sp, $sp, 4");
        code.addCode("lw $t0, 0($sp)");
        code.addCode(node.getChildren().get(1).getCode());
        code.addCode("lw $t1, 0($sp)");
        code.addCode("add $sp, $sp, 4");
        code.addCode("add $t0, $t0, $t1");
        if (node.getChildren().get(0).getType() == Type.getTypeByName("double", 1))
            code.addCode("s.s $f0, 0($t0)");
        else
            code.addCode("sw $f0, 0($t0)");
        //todo inam index check nashoe ...
        return code;
    }

    public Code arrayPlusArray(Node node1, Node node2, int size) {
        Code code = new Code();
        generateCode(node1);
        code.addCode(node1.getCode());
        code.addCode("sub $sp, $sp, 4");
        code.addCode("sw $t0, 0($sp)");
        generateCode(node2);
        code.addCode(node2.getCode());
        code.addCode("lw $t1, 0($sp)");
        code.addCode("add $sp, $sp, 4");

        code.addCode("lw $t2, 0($t0)");
        code.addCode("lw $t3, 0($t1)");

        code.addCode("add $t2, $t2, $t3");
        code.addCode("add $t2, $t2, 1");
        code.addCode("move $a0, $t2");
        if(size == 1)
            code.addCode("add $a0, $a0, 4");
        else
            code.addCode("mul $a0, $a0, " + size);
        code.addCode("li $v0, 9");
        code.addCode("syscall");

        code.addCode("move $t4, $v0");
        code.addCode("move $t5, $t4");
        code.addCode("sub $t2, $t2, 1");
        code.addCode("sw $t2, 0($t4)");
        code.addCode("lw $t2, 0($t0)");
        code.addCode("add $t4, $t4, 4");
        code.addCode("add $t1, $t1, 4");
        code.addCode("add $t0, $t0, 4");
        Label L1 = new Label();
        L1.createNewName();
        Label L2 = new Label();
        L2.createNewName();
        Label L3 = new Label();
        L3.createNewName();
        code.addCode(L1.getName() + ":");
        code.addCode("beq $t3, 0, " + L2.getName());
        if (size == 1) code.addCode("lb $t6, 0($t1)");
        else code.addCode("lw $t6, 0($t1)");
        if (size == 1) code.addCode("sb $t6, 0($t4)");
        else code.addCode("sw $t6, 0($t4)");
        code.addCode("add $t4, $t4, " + size);
        code.addCode("add $t1, $t1, " + size);
        code.addCode("sub $t3, $t3, 1");
        code.addCode("j " + L1.getName());
        code.addCode(L2.getName() + ":");
        code.addCode("beq $t2, 0, " + L3.getName());
        if (size == 1) code.addCode("lb $t6, 0($t0)");
        else code.addCode("lw $t6, 0($t1)");
        if (size == 1) code.addCode("sb $t6, 0($t4)");
        code.addCode("add $t4, $t4, " + size);
        code.addCode("add $t0, $t0, " + size);
        code.addCode("sub $t2, $t2, 1");
        code.addCode("j " + L2.getName());
        code.addCode(L3.getName() + ":");
        if(size == 1)
            code.addCode("sb $zero, 0($t4)");
        code.addCode("move $t0, $t5");
        return code;
    }

    public Code compareString(Node node1, Node node2) {
        Code code = new Code();
        generateCode(node1);
        code.addCode(node1.getCode());
        code.addCode("sub $sp, $sp, 4");
        code.addCode("sw $t0, 0($sp)");

        generateCode(node2);
        code.addCode(node2.getCode());
        code.addCode("lw $t1, 0($sp)");
        code.addCode("add $sp, $sp, 4");

        code.addCode("lw $t2, 0($t0)");
        code.addCode("lw $t3, 0($t1)");

        Label L1 = new Label();
        L1.createNewName();
        Label L2 = new Label();
        L2.createNewName();
        Label L3 = new Label();
        L3.createNewName();
        Label L4 = new Label();
        L4.createNewName();

        code.addCode("bne $t2, $t3, " + L1.getName());
        code.addCode("add $t0, $t0, 4");
        code.addCode("add $t1, $t1, 4");

        code.addCode(L2.getName() + " :");
        code.addCode("beq $t2, 0, " + L3.getName());
        code.addCode("lb $t4, 0($t0)");
        code.addCode("lb $t5, 0($t1)");
        code.addCode("bne $t4, $t5, " + L1.getName());
        code.addCode("sub $t2, $t2, 1");
        code.addCode("j " + L2.getName());
        code.addCode(L3.getName() + " :");
        code.addCode("li $t0, 1");
        code.addCode("j " + L4.getName());
        code.addCode(L1.getName() + " :");
        code.addCode("li $t0, 0");
        code.addCode(L4.getName() + " :");
        //todo bayad in doros she
        //        if (node.getProductionRule() == ProductionRule.Expr_EQUAL_Expr)
//            code.addCode("xor $t0, $t0, 1");
        return code;
    }


    public void call(Node node) {
        if (node.getProductionRule().equals("IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS")) {
            simpleCall(node);
        } else {
            extendCall(node);
        }
    }

    public Code simpleCall(Node node) {
        Code code = new Code();
        return code;
    }

    public Code extendCall(Node node) {
        Code code = new Code();
        return code;
    }
}

enum ProductionRule {
    Decl_DeclStar,
    EPSILON,
    VariableDecl,
    FunctionDecl,
    ClassDecl,
    InterfaceDecl,
    Variable_SEMICOLON,
    Type_IDENTIFIER,
    INT,
    DOUBLE,
    BOOL,
    STRING,
    IDENTIFIER,
    Type_OPENCLOSEBRACKET,
    Type_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_StmtBlock,
    VOID_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_StmtBlock,
    Variable_CommaVariables,
    COMMA_Variable_CommaVariables,
    CLASS_IDENTIFIER_ClassDeclExtends_ClassDeclImplements_OPENCURLYBRACES_FieldStar_CLOSECURLYBRACES,
    DOUBLELITERAL,
    EXTENDS_IDENTIFIER,
    IMPLEMENTS_IDENTIFIER_CommaIdentifiers,
    COMMA_IDENTIFIER_CommaIdentifiers,
    Field_FieldStar,
    AccessMode_VariableDecl,
    AccessMode_FunctionDecl,
    PRIVATE,
    PROTECTED,
    PUBLIC,
    INTERFACE_IDENTIFIER_OPENCURLYBRACES_PrototypeStar_CLOSECURLYBRACES,
    Prototype_PrototypeStar,
    Type_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_SEMICOLON,
    VOID_IDENTIFIER_OPENPARENTHESIS_Formals_CLOSEPARENTHESIS_SEMICOLON,
    OPENCURLYBRACES_InsideStmtBlock_CLOSECURLYBRACES,
    VariableDecl_InsideStmtBlock,
    StmtStar,
    Stmt_StmtStar,
    ExprPrime_SEMICOLON,
    IfStmt,
    WhileStmt,
    ForStmt,
    BreakStmt,
    ContinueStmt,
    ReturnStmt,
    PrintStmt,
    StmtBlock,
    Expr,
    IF_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS_Stmt_ElsePrime,
    ELSE_Stmt,
    WHILE_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS_Stmt,
    FOR_OPENPARENTHESIS_ExprPrime_SEMICOLON_Expr_SEMICOLON_ExprPrime_CLOSEPARENTHESIS_Stmt,
    RETURN_ExprPrime_SEMICOLON,
    BREAK_SEMICOLON,
    CONTINUE_SEMICOLON,
    PRINT_OPENPARENTHESIS_Expr_PrintCommaExpr_CLOSEPARENTHESIS_SEMICOLON,
    COMMA_Expr_PrintCommaExpr,
    LValue_ASSIGN_Expr,
    Constant,
    LValue,
    THIS,
    Call,
    OPENPARENTHESIS_Expr_CLOSEPARENTHESIS,
    Expr_PLUS_Expr,
    Expr_MINUS_Expr,
    Expr_MULTIPLY_Expr,
    Expr_DIVIDE_Expr,
    Expr_MOD_Expr,
    MINUS_Expr,
    Expr_LESS_Expr,
    Expr_LESSEQUAL_Expr,
    Expr_GREATER_Expr,
    Expr_GREATEREQUAL_Expr,
    Expr_EQUAL_Expr,
    Expr_NOTEQUAL_Expr,
    Expr_AND_Expr,
    Expr_OR_Expr,
    NOT_Expr,
    READINTEGER_OPENPARENTHESIS_CLOSEPARENTHESIS,
    READLINE_OPENPARENTHESIS_CLOSEPARENTHESIS,
    NEW_IDENTIFIER,
    NEWARRAY_OPENPARENTHESIS_Expr_COMMA_Type_CLOSEPARENTHESIS,
    ITOD_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS,
    DTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS,
    ITOB_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS,
    BTOI_OPENPARENTHESIS_Expr_CLOSEPARENTHESIS,
    Expr_DOT_IDENTIFIER,
    Expr_OPENBRACKET_Expr_CLOSEBRACKET,
    IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS,
    Expr_DOT_IDENTIFIER_OPENPARENTHESIS_Actuals_CLOSEPARENTHESIS,
    Expr_ActualsCommaExpr,
    COMMA_Expr_ActualsCommaExpr,
    INTLITERAL,
    BOOLEANLITERAL,
    STRINGLITERAL,
    NULL,
    TERMINAL
}

enum Operator {
    PLUS, MINUS, MULT, EQ, DIV, MOD, SINGLE_MINUS, LT, LTEQ, GT, GTEQ, EQEQ, ANDAND, NOTEQ, SINGLE_NOT, OROR
}

enum LeftHand {
    Program,
    DeclStar,
    Decl ,
    VariableDecl,
    Variable,
    Type,
    FunctionDecl,
    Formals,
    CommaVariables,
    ClassDecl,
    ClassDeclImplements,
    ClassDeclExtends,
    CommaIdentifiers,
    FieldStar,
    Field,
    AccessMode,
    InterfaceDecl,
    PrototypeStar,
    Prototype,
    StmtBlock,
    InsideStmtBlock,
    StmtStar,
    Stmt,
    ExprPrime,
    IfStmt,
    ElsePrime,
    WhileStmt,
    ForStmt,
    ReturnStmt,
    BreakStmt,
    ContinueStmt,
    PrintStmt,
    PrintCommaExpr,
    Expr,
    LValue,
    Call,
    Actuals,
    ActualsCommaExpr,
    Constant,
    INTLITERAL,
    DOUBLE,
    DOUBLELITERAL,
    BOOLEANLITERAL,
    STRINGLITERAL,
    NULL,
    IDENTIFIER,
    INT,
    STRING,
    BOOL
}

enum AccessMode {
    PROTECTED, PUBLIC, PRIVATE;
}

class Clazz{
    private static ArrayList<Clazz> clazzes = new ArrayList<Clazz>();
    private ArrayList<Variable> variables = new ArrayList<>();
    private ArrayList<Function> functions = new ArrayList<>();
    private Type type;
    private String name;
    private boolean isSetAttributesAndFunctions = false;

    public Clazz(){
        clazzes.add(this);
    }

    public static Clazz getClazzByName(String name){
        for (Clazz clazz : getClazzes()){
            if(clazz.getName().equals(name))return clazz;
        }
        return null;
    }

    public static ArrayList<Clazz> getClazzes() {
        return clazzes;
    }

    public static void setClazzes(ArrayList<Clazz> clazzes) {
        Clazz.clazzes = clazzes;
    }

    public ArrayList<Variable> getVariables() {
        return variables;
    }

    public Clazz getParent(){
        if(this.getType().getParent() == null)return null;
        return Clazz.getClazzByName(this.getType().getParent().getName());
    }

    public void setVariables(ArrayList<Variable> variables) {
        this.variables = variables;
    }

    public ArrayList<Function> getFunctions() {
        return functions;
    }

    public void setFunctions(ArrayList<Function> functions) {
        this.functions = functions;
    }

    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isSetAttributesAndFunctions() {
        return isSetAttributesAndFunctions;
    }

    public void setSetAttributesAndFunctions(boolean setAttributesAndFunctions) {
        isSetAttributesAndFunctions = setAttributesAndFunctions;
    }
}

class Code {
    private String text = "";

    public void addCode(String code){
        text = text + code + '\n';
    }

    public void addCode(Code code){
        text = text + code.text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }
}


class Function {
    private String name;
    private Type type;
    private AccessMode accessMode = AccessMode.PUBLIC;
    private ArrayList<Variable> parameter = new ArrayList<Variable>();
    private Node node;
    private Label label;

    public Function(){
        this.accessMode = AccessMode.PUBLIC;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public ArrayList<Variable> getParameter() {
        return parameter;
    }

    public void setParameter(ArrayList<Variable> parameter) {
        this.parameter = parameter;
    }

    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public AccessMode getAccessMode() {
        return accessMode;
    }

    public void setAccessMode(AccessMode accessMode) {
        this.accessMode = accessMode;
    }

    public Node getNode() {
        return node;
    }

    public void setNode(Node node) {
        this.node = node;
    }

    public Label getLabel() {
        return label;
    }

    public void setLabel(Label label) {
        this.label = label;
    }
}


class Label {

    private String name;
    static int number = 0;


    public void setName(String name){
        this.name = name;
    }

    public String getName(){
        return name;
    }

    public void createNewName(){
        setName("L" + number);
        number += 1;
    }
}


class Node {
    private AccessMode accessMode;
    private LeftHand leftHand;
    private ProductionRule productionRule;
    private ArrayList<Node> children = new ArrayList<Node>();
    private Object value;
    private Code code;
    private Label breakLabel = new Label();
    private Label continueLabel = new Label();

    private String typeName;
    private int arrayDegree = 0;

    private Type type;
    private ArrayList<Variable> definedVariables = new ArrayList<Variable>();
    private ArrayList<Function> definedFunctions = new ArrayList<>();
    private int index;
    private Node parent;

    private ArrayList<Type> actualsTypes = new ArrayList<Type>();

    public Node(LeftHand leftHand, ProductionRule productionRule){
        this.leftHand = leftHand;
        this.productionRule = productionRule;
    }


    public Label getBreakLabel() {
        return breakLabel;
    }

    public void setBreakLabel(Label breakLabel) {
        this.breakLabel = breakLabel;
    }

    public Label getContinueLabel() {
        return continueLabel;
    }

    public void setContinueLabel(Label continueLabel) {
        this.continueLabel = continueLabel;
    }
    public ProductionRule getProductionRule() {
        return productionRule;
    }

    public void setProductionRule(ProductionRule productionRule) {
        this.productionRule = productionRule;
    }

    public ArrayList<Node> getChildren() {
        return children;
    }

    public void setChildren(ArrayList<Node> children) {
        this.children = children;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public LeftHand getLeftHand() {
        return leftHand;
    }

    public void setLeftHand(LeftHand leftHand) {
        this.leftHand = leftHand;
    }

    public ArrayList<Variable> getDefinedVariables() {
        return definedVariables;
    }

    public int getIndex() {
        return index;
    }

    public void setIndex(int index) {
        this.index = index;
    }

    public Node getParent() {
        return parent;
    }

    public void setParent(Node parent) {
        this.parent = parent;
    }

    public String getTypeName() {
        return typeName;
    }

    public void setTypeName(String typeName) {
        this.typeName = typeName;
    }

    public int getArrayDegree() {
        return arrayDegree;
    }

    public void setArrayDegree(int arrayDegree) {
        this.arrayDegree = arrayDegree;
    }

    public AccessMode getAccessMode() {
        return accessMode;
    }

    public void setAccessMode(AccessMode accessMode) {
        this.accessMode = accessMode;
    }

    public ArrayList<Function> getDefinedFunctions() {
        return definedFunctions;
    }

    public void setDefinedFunctions(ArrayList<Function> definedFunctions) {
        this.definedFunctions = definedFunctions;
    }

    public Code getCode() {
        return code;
    }

    public void setCode(Code code) {
        this.code = code;
    }

    public ArrayList<Type> getActualsTypes() {
        return actualsTypes;
    }

    public void setActualsTypes(ArrayList<Type> actualsTypes) {
        this.actualsTypes = actualsTypes;
    }
}

class Type {
    static class PreType{
        private String name, parent;

        public PreType(String name, String parent){
            this.name = name;
            this.parent = parent;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getParent() {
            return parent;
        }

        public void setParent(String parent) {
            this.parent = parent;
        }
    }

    public static ArrayList<Type> allTypes = new ArrayList<>();
    public static ArrayList<Type.PreType> allPreTypes = new ArrayList<>();

    private Type parent;
    private int arrayDegree;
    private String name;

    public static void createPreType(String name, String parent){
        Type.PreType preType = new Type.PreType(name, parent);
        allPreTypes.add(preType);
    }

    //todo age circular bashe mitereke
    public static ArrayList<Type> getAllTypes(){
        return allTypes;
    }

    public static boolean createTypes(){
        allPreTypes.add(new Type.PreType("void", null));
        allPreTypes.add(new Type.PreType("int", null));
        allPreTypes.add(new Type.PreType("double", null));
        allPreTypes.add(new Type.PreType("bool", null));
        allPreTypes.add(new Type.PreType("string", null));
        allPreTypes.add(new Type.PreType("null", null));
        for (int i = 0; i < allPreTypes.size(); i++) {
            for (int j = 0; j < allPreTypes.size(); j++) {
                if (i != j) {
                    if (allPreTypes.get(i).getName().equals(allPreTypes.get(j).getName())) {
                        Compiler.semanticError();
                    }
                }
            }
        }
        for (Type.PreType p: allPreTypes){
            Type type = new Type();
            type.setName(p.getName());
            allTypes.add(type);
        }
        for (int i = 0; i < allPreTypes.size(); i++){
            String parentName = allPreTypes.get(i).getParent();
            if(parentName == null) continue;
            if (parentName.equals("int") || parentName.equals("double") || parentName.equals("bool") || parentName.equals("string"))
                Compiler.semanticError();
            if (parentName.equals(allPreTypes.get(i).name))
                Compiler.semanticError();
            Type x = getTypeByName(parentName, 0);
            if (x == null)
                Compiler.semanticError();
            else
                allTypes.get(i).setParent(x);
        }
        return true;
    }

    public static Type createArrayType(Type type){
        for(Type type1 : allTypes){
            if(type1.name.equals(type.name) && type1.arrayDegree == type.arrayDegree + 1)
                return type1;
        }
        Type type1 = new Type();
        type1.arrayDegree = type.arrayDegree + 1;
        type1.name = type.name;
        allTypes.add(type1);
        return type1;
    }

    public static Type getTypeByName(String name, int degree){
        for(Type type : allTypes)
            if(type.name.equals(name) && type.arrayDegree == degree)
                return type;
        Compiler.semanticError();
        return null;
    }

    public static boolean possibleNull(Type t1, Type t2, Operator operator){
        Type NULL = getTypeByName("null", 0);
        Type INT = getTypeByName("int", 0);
        Type DOUBLE = getTypeByName("double", 0);
        Type BOOLEAN = getTypeByName("bool", 0);
        Type STRING = getTypeByName("string", 0);

        if (t1.getArrayDegree() > 0 || t2.getArrayDegree() > 0) return false;

        if (operator != Operator.EQEQ && operator != Operator.NOTEQ && operator != Operator.EQ)
            return false;

        if (t1.equals(INT) || t1.equals(DOUBLE) || t1.equals(BOOLEAN) || t1.equals(STRING)) return false;

        if (t1.equals(NULL)){
            if (operator == Operator.EQ) return false;
            if (t2.equals(NULL)) return true;
            if(t2.equals(INT) || t2.equals(DOUBLE) || t2.equals(BOOLEAN) || t2.equals(STRING))return false;
            if (operator == Operator.EQEQ || operator == Operator.NOTEQ) return true;
            return false;
        }

        return true;
    }

    public static boolean possible(Type t1, Type t2, Operator operator){

        Type NULL = getTypeByName("null", 0);
        Type INT = getTypeByName("int", 0);
        Type DOUBLE = getTypeByName("double", 0);
        Type BOOLEAN = getTypeByName("bool", 0);
        Type STRING = getTypeByName("string", 0);
        Type VOID = getTypeByName("void", 0);

        if (operator != Operator.EQEQ && operator != Operator.NOTEQ && operator != Operator.EQ){
            if(t1 != t2) return false;
        }

        if (t1.equals(VOID) || t2.equals(VOID))return false;

        if (t1.equals(NULL) || t2.equals(NULL))return possibleNull(t1, t2, operator);




        if(operator == Operator.MOD && t1 != INT) return false;
        if((operator == Operator.MINUS || operator == Operator.DIV || operator == Operator.MULT)
                && (t1 != INT && t1 != DOUBLE)) return false;
        if((operator == Operator.PLUS) && (t1 != INT && t1 != DOUBLE && t1 != STRING && t1.arrayDegree == 0)) return false;
        if((operator == Operator.ANDAND || operator == Operator.OROR) && t1 != BOOLEAN) return false;
        if((operator == Operator.LT || operator == Operator.GT || operator == Operator.LTEQ || operator == Operator.GTEQ)
                && (t1 != DOUBLE && t1 != INT)) return false;
        if (operator == Operator.EQEQ || operator == Operator.NOTEQ){
            if (!Compiler.isConvertibleTo(t1, t2) && !Compiler.isConvertibleTo(t2, t1))return false;
        }
        //System.out.println("check eq type");
        //System.out.println(t1 + " " + t2);
        if (operator == Operator.EQ && !Compiler.isConvertibleTo(t2, t1))return false;
        //System.out.println("ok");
        return true;
    }

    public static boolean possible(Type t1, Operator operator){
        Type INT = getTypeByName("int", 0);
        Type DOUBLE = getTypeByName("double", 0);
        Type BOOLEAN = getTypeByName("bool", 0);
        if(operator == Operator.SINGLE_NOT && t1 == BOOLEAN) return true;
        if(operator == Operator.SINGLE_MINUS && (t1 == INT || t1 == DOUBLE)) return true;
        return false;
    }

    public int getArrayDegree(){
        return this.arrayDegree;
    }

    public Type getParent() {
        return parent;
    }

    public void setParent(Type parent) {
        this.parent = parent;
    }

    public int isArray() {
        return arrayDegree;
    }

    public void setArray(int array) {
        arrayDegree = array;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}


class Variable {
    private String name;
    private Type type;
    private int nodeIndex;
    private int number;
    private AccessMode accessMode = AccessMode.PUBLIC;

    public Variable() {
        this.accessMode = AccessMode.PUBLIC;
    }

    public Variable(String name, Type type, int number, AccessMode accessMode) {
        this.name = name;
        this.type = type;
        this.number = number;
        this.accessMode = accessMode;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public AccessMode getAccessMode() {
        return accessMode;
    }

    public void setAccessMode(AccessMode accessMode) {
        this.accessMode = accessMode;
    }

    public int getNodeIndex() {
        return nodeIndex;
    }

    public void setNodeIndex(int nodeIndex) {
        this.nodeIndex = nodeIndex;
    }

    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

}

/** CUP generated class containing symbol constants. */
class sym {
    /* terminals */
    public static final int CLOSECURLYBRACES = 34;
    public static final int DIVIDE = 5;
    public static final int READLINE = 36;
    public static final int BOOLEANLITERAL = 23;
    public static final int UMINUS = 7;
    public static final int DOUBLE = 19;
    public static final int NOTEQUAL = 13;
    public static final int CONTINUE = 59;
    public static final int PRIVATE = 50;
    public static final int GREATER = 10;
    public static final int INTERFACE = 45;
    public static final int INT = 18;
    public static final int OPENCURLYBRACES = 33;
    public static final int FOR = 56;
    public static final int LESS = 8;
    public static final int MINUS = 3;
    public static final int SEMICOLON = 49;
    public static final int NOT = 16;
    public static final int AND = 14;
    public static final int READINTEGER = 35;
    public static final int LESSEQUAL = 9;
    public static final int OR = 15;
    public static final int COMMA = 48;
    public static final int BOOL = 20;
    public static final int CLASS = 44;
    public static final int NEWARRAY = 38;
    public static final int OPENCLOSEBRACKET = 29;
    public static final int PLUS = 2;
    public static final int MULTIPLY = 4;
    public static final int ASSIGN = 61;
    public static final int IF = 53;
    public static final int THIS = 62;
    public static final int DOT = 17;
    public static final int CLOSEPARENTHESIS = 32;
    public static final int EOF = 0;
    public static final int RETURN = 57;
    public static final int DOUBLELITERAL = 25;
    public static final int EQUAL = 12;
    public static final int NEW = 37;
    public static final int error = 1;
    public static final int CLOSEBRACKET = 28;
    public static final int NULL = 26;
    public static final int MOD = 6;
    public static final int BREAK = 58;
    public static final int VOID = 43;
    public static final int DTOI = 40;
    public static final int GREATEREQUAL = 11;
    public static final int INTLITERAL = 22;
    public static final int OPENPARENTHESIS = 31;
    public static final int ELSE = 54;
    public static final int PROTECTED = 51;
    public static final int WS = 30;
    public static final int OPENBRACKET = 27;
    public static final int ITOD = 39;
    public static final int WHILE = 55;
    public static final int ITOB = 41;
    public static final int PUBLIC = 52;
    public static final int EXTENDS = 46;
    public static final int BTOI = 42;
    public static final int STRING = 21;
    public static final int STRINGLITERAL = 24;
    public static final int IMPLEMENTS = 47;
    public static final int PRINT = 60;
    public static final int IDENTIFIER = 63;
    public static final String[] terminalNames = new String[] {
            "EOF",
            "error",
            "PLUS",
            "MINUS",
            "MULTIPLY",
            "DIVIDE",
            "MOD",
            "UMINUS",
            "LESS",
            "LESSEQUAL",
            "GREATER",
            "GREATEREQUAL",
            "EQUAL",
            "NOTEQUAL",
            "AND",
            "OR",
            "NOT",
            "DOT",
            "INT",
            "DOUBLE",
            "BOOL",
            "STRING",
            "INTLITERAL",
            "BOOLEANLITERAL",
            "STRINGLITERAL",
            "DOUBLELITERAL",
            "NULL",
            "OPENBRACKET",
            "CLOSEBRACKET",
            "OPENCLOSEBRACKET",
            "WS",
            "OPENPARENTHESIS",
            "CLOSEPARENTHESIS",
            "OPENCURLYBRACES",
            "CLOSECURLYBRACES",
            "READINTEGER",
            "READLINE",
            "NEW",
            "NEWARRAY",
            "ITOD",
            "DTOI",
            "ITOB",
            "BTOI",
            "VOID",
            "CLASS",
            "INTERFACE",
            "EXTENDS",
            "IMPLEMENTS",
            "COMMA",
            "SEMICOLON",
            "PRIVATE",
            "PROTECTED",
            "PUBLIC",
            "IF",
            "ELSE",
            "WHILE",
            "FOR",
            "RETURN",
            "BREAK",
            "CONTINUE",
            "PRINT",
            "ASSIGN",
            "THIS",
            "IDENTIFIER"
    };
}

@SuppressWarnings("FallThrough")
class MyScanner implements java_cup.runtime.Scanner {

    /** This character denotes the end of file. */
    public static final int YYEOF = -1;

    /** Initial size of the lookahead buffer. */
    private static final int ZZ_BUFFERSIZE = 16384;

    // Lexical states.
    public static final int YYINITIAL = 0;
    public static final int STRING = 2;

    /**
     * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
     * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
     *                  at the beginning of a line
     * l is of the form l = 2*k, k a non negative integer
     */
    private static final int ZZ_LEXSTATE[] = {
            0,  0,  1, 1
    };

    /**
     * Top-level table for translating characters to character classes
     */
    private static final int [] ZZ_CMAP_TOP = zzUnpackcmap_top();

    private static final String ZZ_CMAP_TOP_PACKED_0 =
            "\1\0\37\u0100\1\u0200\267\u0100\10\u0300\u1020\u0100";

    private static int [] zzUnpackcmap_top() {
        int [] result = new int[4352];
        int offset = 0;
        offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result);
        return result;
    }

    private static int zzUnpackcmap_top(String packed, int offset, int [] result) {
        int i = 0;       /* index in packed string  */
        int j = offset;  /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            do result[j++] = value; while (--count > 0);
        }
        return j;
    }


    /**
     * Second-level tables for translating characters to character classes
     */
    private static final int [] ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks();

    private static final String ZZ_CMAP_BLOCKS_PACKED_0 =
            "\11\0\1\1\1\2\1\3\1\4\1\5\22\0\1\1"+
                    "\1\6\1\7\2\0\1\10\1\11\1\0\1\12\1\13"+
                    "\1\14\1\15\1\16\1\17\1\20\1\21\1\22\11\23"+
                    "\1\0\1\24\1\25\1\26\1\27\2\0\1\30\3\31"+
                    "\1\32\1\31\2\33\1\34\2\33\1\35\1\33\1\36"+
                    "\1\33\1\37\1\33\1\40\5\33\1\41\2\33\1\42"+
                    "\1\0\1\43\1\0\1\44\1\0\1\45\1\46\1\47"+
                    "\1\50\1\51\1\52\1\53\1\54\1\55\1\33\1\56"+
                    "\1\57\1\60\1\61\1\62\1\63\1\33\1\64\1\65"+
                    "\1\66\1\67\1\70\1\71\1\72\1\73\1\33\1\74"+
                    "\1\75\1\76\7\0\1\3\u01a2\0\2\3\326\0\u0100\3";

    private static int [] zzUnpackcmap_blocks() {
        int [] result = new int[1024];
        int offset = 0;
        offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result);
        return result;
    }

    private static int zzUnpackcmap_blocks(String packed, int offset, int [] result) {
        int i = 0;       /* index in packed string  */
        int j = offset;  /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            do result[j++] = value; while (--count > 0);
        }
        return j;
    }

    /**
     * Translates DFA states to action switch labels.
     */
    private static final int [] ZZ_ACTION = zzUnpackAction();

    private static final String ZZ_ACTION_PACKED_0 =
            "\2\0\2\1\1\2\1\3\1\4\1\0\1\5\1\6"+
                    "\1\7\1\10\1\11\1\12\1\13\1\14\2\15\1\16"+
                    "\1\17\1\20\1\21\4\22\1\23\1\24\15\22\1\25"+
                    "\1\0\1\26\1\27\1\30\1\31\1\32\1\0\1\1"+
                    "\1\33\1\0\1\34\1\35\1\36\3\22\1\37\13\22"+
                    "\1\40\15\22\1\41\2\0\1\15\15\22\1\42\1\22"+
                    "\1\43\1\22\1\44\12\22\1\0\1\33\3\22\1\45"+
                    "\1\22\1\46\3\22\1\47\1\50\3\22\1\51\1\52"+
                    "\1\53\5\22\1\54\1\55\1\56\2\22\1\57\2\22"+
                    "\1\60\1\61\12\22\1\62\4\22\1\63\5\22\1\64"+
                    "\1\65\1\66\4\22\1\67\2\22\1\70\1\22\1\71"+
                    "\1\22\1\72\1\73\5\22\1\74\1\75\1\22\1\76"+
                    "\1\77";

    private static int [] zzUnpackAction() {
        int [] result = new int[197];
        int offset = 0;
        offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
        return result;
    }

    private static int zzUnpackAction(String packed, int offset, int [] result) {
        int i = 0;       /* index in packed string  */
        int j = offset;  /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            do result[j++] = value; while (--count > 0);
        }
        return j;
    }


    /**
     * Translates a state to a row index in the transition table
     */
    private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

    private static final String ZZ_ROWMAP_PACKED_0 =
            "\0\0\0\77\0\176\0\275\0\374\0\176\0\176\0\u013b"+
                    "\0\176\0\176\0\176\0\176\0\176\0\176\0\176\0\u017a"+
                    "\0\u01b9\0\u01f8\0\176\0\u0237\0\u0276\0\u02b5\0\u02f4\0\u0333"+
                    "\0\u0372\0\u03b1\0\u03f0\0\176\0\u042f\0\u046e\0\u04ad\0\u04ec"+
                    "\0\u052b\0\u056a\0\u05a9\0\u05e8\0\u0627\0\u0666\0\u06a5\0\u06e4"+
                    "\0\u0723\0\176\0\u0762\0\176\0\176\0\176\0\176\0\176"+
                    "\0\u07a1\0\u07e0\0\u081f\0\u085e\0\176\0\176\0\176\0\u089d"+
                    "\0\u08dc\0\u091b\0\176\0\u095a\0\u0999\0\u09d8\0\u0a17\0\u0a56"+
                    "\0\u0a95\0\u0ad4\0\u0b13\0\u0b52\0\u0b91\0\u0bd0\0\u02f4\0\u0c0f"+
                    "\0\u0c4e\0\u0c8d\0\u0ccc\0\u0d0b\0\u0d4a\0\u0d89\0\u0dc8\0\u0e07"+
                    "\0\u0e46\0\u0e85\0\u0ec4\0\u0f03\0\176\0\u0f42\0\u0f81\0\u085e"+
                    "\0\u0fc0\0\u0fff\0\u103e\0\u107d\0\u10bc\0\u10fb\0\u113a\0\u1179"+
                    "\0\u11b8\0\u11f7\0\u1236\0\u1275\0\u12b4\0\u02f4\0\u12f3\0\u1332"+
                    "\0\u1371\0\u02f4\0\u13b0\0\u13ef\0\u142e\0\u146d\0\u14ac\0\u14eb"+
                    "\0\u152a\0\u1569\0\u15a8\0\u15e7\0\u1626\0\u1626\0\u1665\0\u16a4"+
                    "\0\u16e3\0\u02f4\0\u1722\0\u02f4\0\u1761\0\u17a0\0\u17df\0\u02f4"+
                    "\0\u02f4\0\u181e\0\u185d\0\u189c\0\u02f4\0\u02f4\0\u02f4\0\u18db"+
                    "\0\u191a\0\u1959\0\u1998\0\u19d7\0\u02f4\0\u02f4\0\u02f4\0\u1a16"+
                    "\0\u1a55\0\u02f4\0\u1a94\0\u1ad3\0\u02f4\0\u02f4\0\u1b12\0\u1b51"+
                    "\0\u1b90\0\u1bcf\0\u1c0e\0\u1c4d\0\u1c8c\0\u1ccb\0\u1d0a\0\u1d49"+
                    "\0\u02f4\0\u1d88\0\u1dc7\0\u1e06\0\u1e45\0\u02f4\0\u1e84\0\u1ec3"+
                    "\0\u1f02\0\u1f41\0\u1f80\0\u02f4\0\u02f4\0\u02f4\0\u1fbf\0\u1ffe"+
                    "\0\u203d\0\u207c\0\u02f4\0\u20bb\0\u20fa\0\u02f4\0\u2139\0\u02f4"+
                    "\0\u2178\0\u02f4\0\u02f4\0\u21b7\0\u21f6\0\u2235\0\u2274\0\u22b3"+
                    "\0\u02f4\0\u02f4\0\u22f2\0\u02f4\0\u02f4";

    private static int [] zzUnpackRowMap() {
        int [] result = new int[197];
        int offset = 0;
        offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
        return result;
    }

    private static int zzUnpackRowMap(String packed, int offset, int [] result) {
        int i = 0;  /* index in packed string  */
        int j = offset;  /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int high = packed.charAt(i++) << 16;
            result[j++] = high | packed.charAt(i++);
        }
        return j;
    }

    /**
     * The transition table of the DFA
     */
    private static final int [] ZZ_TRANS = zzUnpackTrans();

    private static final String ZZ_TRANS_PACKED_0 =
            "\1\0\2\3\1\0\1\3\1\4\1\5\1\6\1\7"+
                    "\1\10\1\11\1\12\1\13\1\14\1\15\1\16\1\17"+
                    "\1\20\1\21\1\22\1\23\1\24\1\25\1\26\6\27"+
                    "\1\30\1\31\1\32\1\27\1\33\1\34\1\0\1\27"+
                    "\1\35\1\36\1\37\1\40\1\41\2\27\1\42\3\27"+
                    "\1\43\1\27\1\44\1\45\1\46\1\47\1\27\1\50"+
                    "\1\51\2\27\1\52\1\53\1\54\2\55\4\0\1\55"+
                    "\1\56\67\55\101\0\1\3\122\0\1\57\61\0\1\60"+
                    "\101\0\1\61\4\0\1\62\75\0\1\63\1\0\2\22"+
                    "\15\0\1\64\30\0\1\64\24\0\1\63\1\0\2\22"+
                    "\101\0\1\65\76\0\1\66\76\0\1\67\72\0\2\27"+
                    "\4\0\12\27\2\0\30\27\25\0\2\27\4\0\12\27"+
                    "\2\0\5\27\1\70\22\27\25\0\2\27\4\0\12\27"+
                    "\2\0\20\27\1\71\7\27\25\0\2\27\4\0\12\27"+
                    "\2\0\5\27\1\72\22\27\46\0\1\73\55\0\2\27"+
                    "\4\0\12\27\2\0\16\27\1\74\1\27\1\75\1\27"+
                    "\1\76\5\27\25\0\2\27\4\0\12\27\2\0\13\27"+
                    "\1\77\2\27\1\100\11\27\25\0\2\27\4\0\12\27"+
                    "\2\0\16\27\1\101\3\27\1\102\5\27\25\0\2\27"+
                    "\4\0\12\27\2\0\13\27\1\103\12\27\1\104\1\27"+
                    "\25\0\2\27\4\0\12\27\2\0\1\27\1\105\14\27"+
                    "\1\106\11\27\25\0\2\27\4\0\12\27\2\0\6\27"+
                    "\1\107\5\27\1\110\1\111\4\27\1\112\5\27\25\0"+
                    "\2\27\4\0\12\27\2\0\5\27\1\113\15\27\1\114"+
                    "\4\27\25\0\2\27\4\0\12\27\2\0\20\27\1\115"+
                    "\2\27\1\116\4\27\25\0\2\27\4\0\12\27\2\0"+
                    "\5\27\1\117\22\27\25\0\2\27\4\0\12\27\2\0"+
                    "\22\27\1\120\5\27\25\0\2\27\4\0\12\27\2\0"+
                    "\10\27\1\121\7\27\1\122\7\27\25\0\2\27\4\0"+
                    "\12\27\2\0\16\27\1\123\11\27\25\0\2\27\4\0"+
                    "\12\27\2\0\10\27\1\124\17\27\100\0\1\125\1\0"+
                    "\14\61\1\126\62\61\2\62\1\0\2\62\1\0\71\62"+
                    "\22\0\2\63\6\0\1\127\16\0\1\127\47\0\2\130"+
                    "\4\0\3\130\12\0\6\130\46\0\2\27\4\0\12\27"+
                    "\2\0\25\27\1\131\2\27\25\0\2\27\4\0\12\27"+
                    "\2\0\11\27\1\132\16\27\25\0\2\27\4\0\12\27"+
                    "\2\0\1\27\1\133\26\27\25\0\2\27\4\0\12\27"+
                    "\2\0\16\27\1\134\11\27\25\0\2\27\4\0\12\27"+
                    "\2\0\5\27\1\135\22\27\25\0\2\27\4\0\12\27"+
                    "\2\0\16\27\1\136\11\27\25\0\2\27\4\0\12\27"+
                    "\2\0\1\27\1\137\26\27\25\0\2\27\4\0\12\27"+
                    "\2\0\15\27\1\140\12\27\25\0\2\27\4\0\12\27"+
                    "\2\0\23\27\1\141\4\27\25\0\2\27\4\0\12\27"+
                    "\2\0\16\27\1\142\11\27\25\0\2\27\4\0\12\27"+
                    "\2\0\21\27\1\143\6\27\25\0\2\27\4\0\12\27"+
                    "\2\0\22\27\1\144\5\27\25\0\2\27\4\0\12\27"+
                    "\2\0\13\27\1\145\14\27\25\0\2\27\4\0\12\27"+
                    "\2\0\20\27\1\146\7\27\25\0\2\27\4\0\12\27"+
                    "\2\0\17\27\1\147\10\27\25\0\2\27\4\0\12\27"+
                    "\2\0\22\27\1\150\5\27\25\0\2\27\4\0\12\27"+
                    "\2\0\16\27\1\151\11\27\25\0\2\27\4\0\12\27"+
                    "\2\0\25\27\1\152\2\27\25\0\2\27\4\0\12\27"+
                    "\2\0\13\27\1\153\14\27\25\0\2\27\4\0\12\27"+
                    "\2\0\11\27\1\154\4\27\1\155\11\27\25\0\2\27"+
                    "\4\0\12\27\2\0\2\27\1\156\25\27\25\0\2\27"+
                    "\4\0\12\27\2\0\22\27\1\157\5\27\25\0\2\27"+
                    "\4\0\12\27\2\0\20\27\1\160\7\27\25\0\2\27"+
                    "\4\0\12\27\2\0\11\27\1\161\16\27\25\0\2\27"+
                    "\4\0\12\27\2\0\23\27\1\162\4\27\25\0\2\27"+
                    "\4\0\12\27\2\0\11\27\1\163\16\27\25\0\2\27"+
                    "\4\0\12\27\2\0\11\27\1\164\16\27\24\0\1\3"+
                    "\72\0\1\165\1\0\1\165\2\0\2\166\75\0\2\27"+
                    "\4\0\1\167\11\27\2\0\30\27\25\0\2\27\4\0"+
                    "\12\27\2\0\15\27\1\170\12\27\25\0\2\27\4\0"+
                    "\12\27\2\0\4\27\1\171\23\27\25\0\2\27\4\0"+
                    "\12\27\2\0\13\27\1\172\14\27\25\0\2\27\4\0"+
                    "\12\27\2\0\1\27\1\173\26\27\25\0\2\27\4\0"+
                    "\12\27\2\0\11\27\1\174\16\27\25\0\2\27\4\0"+
                    "\12\27\2\0\21\27\1\175\6\27\25\0\2\27\4\0"+
                    "\12\27\2\0\22\27\1\176\5\27\25\0\2\27\4\0"+
                    "\12\27\2\0\2\27\1\177\25\27\25\0\2\27\4\0"+
                    "\12\27\2\0\11\27\1\200\16\27\25\0\2\27\4\0"+
                    "\12\27\2\0\5\27\1\201\22\27\25\0\2\27\4\0"+
                    "\12\27\2\0\5\27\1\202\22\27\25\0\2\27\4\0"+
                    "\12\27\2\0\21\27\1\162\6\27\25\0\2\27\4\0"+
                    "\12\27\2\0\13\27\1\203\14\27\25\0\2\27\4\0"+
                    "\12\27\2\0\5\27\1\204\22\27\25\0\2\27\4\0"+
                    "\12\27\2\0\2\27\1\205\1\27\1\206\23\27\25\0"+
                    "\2\27\4\0\12\27\2\0\13\27\1\207\14\27\25\0"+
                    "\2\27\4\0\12\27\2\0\24\27\1\210\3\27\25\0"+
                    "\2\27\4\0\12\27\2\0\22\27\1\211\5\27\25\0"+
                    "\2\27\4\0\12\27\2\0\13\27\1\212\14\27\25\0"+
                    "\2\27\4\0\12\27\2\0\23\27\1\213\4\27\25\0"+
                    "\2\27\4\0\12\27\2\0\11\27\1\214\16\27\25\0"+
                    "\2\27\4\0\12\27\2\0\21\27\1\215\6\27\25\0"+
                    "\2\27\4\0\12\27\2\0\5\27\1\216\22\27\25\0"+
                    "\2\27\4\0\12\27\2\0\4\27\1\217\23\27\25\0"+
                    "\2\27\4\0\12\27\2\0\13\27\1\220\14\27\25\0"+
                    "\2\166\75\0\2\27\4\0\12\27\2\0\20\27\1\221"+
                    "\7\27\25\0\2\27\4\0\12\27\2\0\22\27\1\222"+
                    "\5\27\25\0\2\27\4\0\4\27\1\223\1\224\4\27"+
                    "\2\0\30\27\25\0\2\27\4\0\12\27\2\0\12\27"+
                    "\1\225\15\27\25\0\2\27\4\0\12\27\2\0\21\27"+
                    "\1\226\6\27\25\0\2\27\4\0\12\27\2\0\11\27"+
                    "\1\227\16\27\25\0\2\27\4\0\12\27\2\0\13\27"+
                    "\1\230\14\27\25\0\2\27\4\0\12\27\2\0\15\27"+
                    "\1\231\12\27\25\0\2\27\4\0\12\27\2\0\5\27"+
                    "\1\232\22\27\25\0\2\27\4\0\12\27\2\0\20\27"+
                    "\1\233\7\27\25\0\2\27\4\0\12\27\2\0\1\27"+
                    "\1\234\26\27\25\0\2\27\4\0\12\27\2\0\5\27"+
                    "\1\235\22\27\25\0\2\27\4\0\12\27\2\0\11\27"+
                    "\1\236\16\27\25\0\2\27\4\0\12\27\2\0\20\27"+
                    "\1\237\7\27\25\0\2\27\4\0\12\27\2\0\15\27"+
                    "\1\240\12\27\25\0\2\27\4\0\12\27\2\0\5\27"+
                    "\1\241\22\27\25\0\2\27\4\0\12\27\2\0\20\27"+
                    "\1\242\7\27\25\0\2\27\4\0\12\27\2\0\15\27"+
                    "\1\243\12\27\25\0\2\27\4\0\12\27\2\0\11\27"+
                    "\1\244\16\27\25\0\2\27\4\0\12\27\2\0\15\27"+
                    "\1\245\12\27\25\0\2\27\4\0\12\27\2\0\5\27"+
                    "\1\246\22\27\25\0\2\27\4\0\12\27\2\0\4\27"+
                    "\1\247\23\27\25\0\2\27\4\0\12\27\2\0\14\27"+
                    "\1\250\13\27\25\0\2\27\4\0\12\27\2\0\6\27"+
                    "\1\251\21\27\25\0\2\27\4\0\12\27\2\0\22\27"+
                    "\1\252\5\27\25\0\2\27\4\0\12\27\2\0\3\27"+
                    "\1\253\24\27\25\0\2\27\4\0\12\27\2\0\3\27"+
                    "\1\254\24\27\25\0\2\27\4\0\12\27\2\0\15\27"+
                    "\1\255\12\27\25\0\2\27\4\0\12\27\2\0\7\27"+
                    "\1\256\20\27\25\0\2\27\4\0\12\27\2\0\1\27"+
                    "\1\257\26\27\25\0\2\27\4\0\12\27\2\0\22\27"+
                    "\1\260\5\27\25\0\2\27\4\0\12\27\2\0\15\27"+
                    "\1\261\12\27\25\0\2\27\4\0\12\27\2\0\23\27"+
                    "\1\262\4\27\25\0\2\27\4\0\12\27\2\0\21\27"+
                    "\1\263\6\27\25\0\2\27\4\0\12\27\2\0\5\27"+
                    "\1\264\22\27\25\0\2\27\4\0\12\27\2\0\1\27"+
                    "\1\265\26\27\25\0\2\27\4\0\12\27\2\0\5\27"+
                    "\1\266\22\27\25\0\2\27\4\0\12\27\2\0\22\27"+
                    "\1\267\5\27\25\0\2\27\4\0\12\27\2\0\27\27"+
                    "\1\270\25\0\2\27\4\0\12\27\2\0\5\27\1\271"+
                    "\22\27\25\0\2\27\4\0\12\27\2\0\5\27\1\272"+
                    "\22\27\25\0\2\27\4\0\12\27\2\0\5\27\1\273"+
                    "\22\27\25\0\2\27\4\0\12\27\2\0\15\27\1\274"+
                    "\12\27\25\0\2\27\4\0\12\27\2\0\3\27\1\275"+
                    "\24\27\25\0\2\27\4\0\12\27\2\0\5\27\1\276"+
                    "\22\27\25\0\2\27\4\0\12\27\2\0\7\27\1\277"+
                    "\20\27\25\0\2\27\4\0\12\27\2\0\22\27\1\300"+
                    "\5\27\25\0\2\27\4\0\12\27\2\0\5\27\1\301"+
                    "\22\27\25\0\2\27\4\0\12\27\2\0\4\27\1\302"+
                    "\23\27\25\0\2\27\4\0\12\27\2\0\5\27\1\303"+
                    "\22\27\25\0\2\27\4\0\12\27\2\0\21\27\1\304"+
                    "\6\27\25\0\2\27\4\0\12\27\2\0\20\27\1\305"+
                    "\7\27\3\0";

    private static int [] zzUnpackTrans() {
        int [] result = new int[9009];
        int offset = 0;
        offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
        return result;
    }

    private static int zzUnpackTrans(String packed, int offset, int [] result) {
        int i = 0;       /* index in packed string  */
        int j = offset;  /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            value--;
            do result[j++] = value; while (--count > 0);
        }
        return j;
    }


    /** Error code for "Unknown internal scanner error". */
    private static final int ZZ_UNKNOWN_ERROR = 0;
    /** Error code for "could not match input". */
    private static final int ZZ_NO_MATCH = 1;
    /** Error code for "pushback value was too large". */
    private static final int ZZ_PUSHBACK_2BIG = 2;

    /**
     * Error messages for {@link #ZZ_UNKNOWN_ERROR}, {@link #ZZ_NO_MATCH}, and
     * {@link #ZZ_PUSHBACK_2BIG} respectively.
     */
    private static final String ZZ_ERROR_MSG[] = {
            "Unknown internal scanner error",
            "Error: could not match input",
            "Error: pushback value was too large"
    };

    /**
     * ZZ_ATTRIBUTE[aState] contains the attributes of state {@code aState}
     */
    private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

    private static final String ZZ_ATTRIBUTE_PACKED_0 =
            "\2\0\1\11\2\1\2\11\1\0\7\11\3\1\1\11"+
                    "\10\1\1\11\15\1\1\11\1\0\5\11\1\0\2\1"+
                    "\1\0\3\11\3\1\1\11\31\1\1\11\2\0\35\1"+
                    "\1\0\120\1";

    private static int [] zzUnpackAttribute() {
        int [] result = new int[197];
        int offset = 0;
        offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
        return result;
    }

    private static int zzUnpackAttribute(String packed, int offset, int [] result) {
        int i = 0;       /* index in packed string  */
        int j = offset;  /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            do result[j++] = value; while (--count > 0);
        }
        return j;
    }

    /** Input device. */
    private java.io.Reader zzReader;

    /** Current state of the DFA. */
    private int zzState;

    /** Current lexical state. */
    private int zzLexicalState = YYINITIAL;

    /**
     * This buffer contains the current text to be matched and is the source of the {@link #yytext()}
     * string.
     */
    private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

    /** Text position at the last accepting state. */
    private int zzMarkedPos;

    /** Current text position in the buffer. */
    private int zzCurrentPos;

    /** Marks the beginning of the {@link #yytext()} string in the buffer. */
    private int zzStartRead;

    /** Marks the last character in the buffer, that has been read from input. */
    private int zzEndRead;

    /**
     * Whether the scanner is at the end of file.
     * @see #yyatEOF
     */
    private boolean zzAtEOF;

    /**
     * The number of occupied positions in {@link #zzBuffer} beyond {@link #zzEndRead}.
     *
     * <p>When a lead/high surrogate has been read from the input stream into the final
     * {@link #zzBuffer} position, this will have a value of 1; otherwise, it will have a value of 0.
     */
    private int zzFinalHighSurrogate = 0;

    /** Number of newlines encountered up to the start of the matched text. */
    private int yyline;

    /** Number of characters from the last newline up to the start of the matched text. */
    private int yycolumn;

    /** Number of characters up to the start of the matched text. */
    @SuppressWarnings("unused")
    private long yychar;

    /** Whether the scanner is currently at the beginning of a line. */
    @SuppressWarnings("unused")
    private boolean zzAtBOL = true;

    /** Whether the user-EOF-code has already been executed. */
    private boolean zzEOFDone;

    /* user code: */
    String string = "";

    public Symbol token(int tokenType, String content) {
        return new Symbol(tokenType, content) ;
    }


    /**
     * Creates a new scanner
     *
     * @param   in  the java.io.Reader to read input from.
     */
    public MyScanner(java.io.Reader in) {
        this.zzReader = in;
    }

    /**
     * Translates raw input code points to DFA table row
     */
    private static int zzCMap(int input) {
        int offset = input & 255;
        return offset == input ? ZZ_CMAP_BLOCKS[offset] : ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input >> 8] | offset];
    }

    /**
     * Refills the input buffer.
     *
     * @return {@code false} iff there was new input.
     * @exception java.io.IOException  if any I/O-Error occurs
     */
    private boolean zzRefill() throws java.io.IOException {

        /* first: make room (if you can) */
        if (zzStartRead > 0) {
            zzEndRead += zzFinalHighSurrogate;
            zzFinalHighSurrogate = 0;
            System.arraycopy(zzBuffer, zzStartRead,
                    zzBuffer, 0,
                    zzEndRead - zzStartRead);

            /* translate stored positions */
            zzEndRead -= zzStartRead;
            zzCurrentPos -= zzStartRead;
            zzMarkedPos -= zzStartRead;
            zzStartRead = 0;
        }

        /* is the buffer big enough? */
        if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) {
            /* if not: blow it up */
            char newBuffer[] = new char[zzBuffer.length * 2];
            System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
            zzBuffer = newBuffer;
            zzEndRead += zzFinalHighSurrogate;
            zzFinalHighSurrogate = 0;
        }

        /* fill the buffer with new input */
        int requested = zzBuffer.length - zzEndRead;
        int numRead = zzReader.read(zzBuffer, zzEndRead, requested);

        /* not supposed to occur according to specification of java.io.Reader */
        if (numRead == 0) {
            throw new java.io.IOException(
                    "Reader returned 0 characters. See JFlex examples/zero-reader for a workaround.");
        }
        if (numRead > 0) {
            zzEndRead += numRead;
            if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) {
                if (numRead == requested) { // We requested too few chars to encode a full Unicode character
                    --zzEndRead;
                    zzFinalHighSurrogate = 1;
                } else {                    // There is room in the buffer for at least one more char
                    int c = zzReader.read();  // Expecting to read a paired low surrogate char
                    if (c == -1) {
                        return true;
                    } else {
                        zzBuffer[zzEndRead++] = (char)c;
                    }
                }
            }
            /* potentially more input available */
            return false;
        }

        /* numRead < 0 ==> end of stream */
        return true;
    }


    /**
     * Closes the input reader.
     *
     * @throws java.io.IOException if the reader could not be closed.
     */
    public final void yyclose() throws java.io.IOException {
        zzAtEOF = true; // indicate end of file
        zzEndRead = zzStartRead; // invalidate buffer

        if (zzReader != null) {
            zzReader.close();
        }
    }


    /**
     * Resets the scanner to read from a new input stream.
     *
     * <p>Does not close the old reader.
     *
     * <p>All internal variables are reset, the old input stream <b>cannot</b> be reused (internal
     * buffer is discarded and lost). Lexical state is set to {@code ZZ_INITIAL}.
     *
     * <p>Internal scan buffer is resized down to its initial length, if it has grown.
     *
     * @param reader The new input stream.
     */
    public final void yyreset(java.io.Reader reader) {
        zzReader = reader;
        zzEOFDone = false;
        yyResetPosition();
        zzLexicalState = YYINITIAL;
        if (zzBuffer.length > ZZ_BUFFERSIZE) {
            zzBuffer = new char[ZZ_BUFFERSIZE];
        }
    }

    /**
     * Resets the input position.
     */
    private final void yyResetPosition() {
        zzAtBOL  = true;
        zzAtEOF  = false;
        zzCurrentPos = 0;
        zzMarkedPos = 0;
        zzStartRead = 0;
        zzEndRead = 0;
        zzFinalHighSurrogate = 0;
        yyline = 0;
        yycolumn = 0;
        yychar = 0L;
    }


    /**
     * Returns whether the scanner has reached the end of the reader it reads from.
     *
     * @return whether the scanner has reached EOF.
     */
    public final boolean yyatEOF() {
        return zzAtEOF;
    }


    /**
     * Returns the current lexical state.
     *
     * @return the current lexical state.
     */
    public final int yystate() {
        return zzLexicalState;
    }


    /**
     * Enters a new lexical state.
     *
     * @param newState the new lexical state
     */
    public final void yybegin(int newState) {
        zzLexicalState = newState;
    }


    /**
     * Returns the text matched by the current regular expression.
     *
     * @return the matched text.
     */
    public final String yytext() {
        return new String(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);
    }


    /**
     * Returns the character at the given position from the matched text.
     *
     * <p>It is equivalent to {@code yytext().charAt(pos)}, but faster.
     *
     * @param position the position of the character to fetch. A value from 0 to {@code yylength()-1}.
     *
     * @return the character at {@code position}.
     */
    public final char yycharat(int position) {
        return zzBuffer[zzStartRead + position];
    }


    /**
     * How many characters were matched.
     *
     * @return the length of the matched text region.
     */
    public final int yylength() {
        return zzMarkedPos-zzStartRead;
    }


    /**
     * Reports an error that occurred while scanning.
     *
     * <p>In a well-formed scanner (no or only correct usage of {@code yypushback(int)} and a
     * match-all fallback rule) this method will only be called with things that
     * "Can't Possibly Happen".
     *
     * <p>If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty
     * scanner etc.).
     *
     * <p>Usual syntax/scanner level error handling should be done in error fallback rules.
     *
     * @param errorCode the code of the error message to display.
     */
    private static void zzScanError(int errorCode) {
        String message;
        try {
            message = ZZ_ERROR_MSG[errorCode];
        } catch (ArrayIndexOutOfBoundsException e) {
            message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
        }

        throw new Error(message);
    }


    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * <p>They will be read again by then next call of the scanning method.
     *
     * @param number the number of characters to be read again. This number must not be greater than
     *     {@link #yylength()}.
     */
    public void yypushback(int number)  {
        if ( number > yylength() )
            zzScanError(ZZ_PUSHBACK_2BIG);

        zzMarkedPos -= number;
    }


    /**
     * Contains user EOF-code, which will be executed exactly once,
     * when the end of file is reached
     */
    private void zzDoEOF() throws java.io.IOException {
        if (!zzEOFDone) {
            zzEOFDone = true;

            yyclose();    }
    }




    /**
     * Resumes scanning until the next regular expression is matched, the end of input is encountered
     * or an I/O-Error occurs.
     *
     * @return the next token.
     * @exception java.io.IOException if any I/O-Error occurs.
     */
    @Override  public Symbol next_token() throws java.io.IOException {
        int zzInput;
        int zzAction;

        // cached fields:
        int zzCurrentPosL;
        int zzMarkedPosL;
        int zzEndReadL = zzEndRead;
        char[] zzBufferL = zzBuffer;

        int [] zzTransL = ZZ_TRANS;
        int [] zzRowMapL = ZZ_ROWMAP;
        int [] zzAttrL = ZZ_ATTRIBUTE;

        while (true) {
            zzMarkedPosL = zzMarkedPos;

            boolean zzR = false;
            int zzCh;
            int zzCharCount;
            for (zzCurrentPosL = zzStartRead  ;
                 zzCurrentPosL < zzMarkedPosL ;
                 zzCurrentPosL += zzCharCount ) {
                zzCh = Character.codePointAt(zzBufferL, zzCurrentPosL, zzMarkedPosL);
                zzCharCount = Character.charCount(zzCh);
                switch (zzCh) {
                    case '\u000B':  // fall through
                    case '\u000C':  // fall through
                    case '\u0085':  // fall through
                    case '\u2028':  // fall through
                    case '\u2029':
                        yyline++;
                        yycolumn = 0;
                        zzR = false;
                        break;
                    case '\r':
                        yyline++;
                        yycolumn = 0;
                        zzR = true;
                        break;
                    case '\n':
                        if (zzR)
                            zzR = false;
                        else {
                            yyline++;
                            yycolumn = 0;
                        }
                        break;
                    default:
                        zzR = false;
                        yycolumn += zzCharCount;
                }
            }

            if (zzR) {
                // peek one character ahead if it is
                // (if we have counted one line too much)
                boolean zzPeek;
                if (zzMarkedPosL < zzEndReadL)
                    zzPeek = zzBufferL[zzMarkedPosL] == '\n';
                else if (zzAtEOF)
                    zzPeek = false;
                else {
                    boolean eof = zzRefill();
                    zzEndReadL = zzEndRead;
                    zzMarkedPosL = zzMarkedPos;
                    zzBufferL = zzBuffer;
                    if (eof)
                        zzPeek = false;
                    else
                        zzPeek = zzBufferL[zzMarkedPosL] == '\n';
                }
                if (zzPeek) yyline--;
            }
            zzAction = -1;

            zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

            zzState = ZZ_LEXSTATE[zzLexicalState];

            // set up zzAction for empty match case:
            int zzAttributes = zzAttrL[zzState];
            if ( (zzAttributes & 1) == 1 ) {
                zzAction = zzState;
            }


            zzForAction: {
                while (true) {

                    if (zzCurrentPosL < zzEndReadL) {
                        zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
                        zzCurrentPosL += Character.charCount(zzInput);
                    }
                    else if (zzAtEOF) {
                        zzInput = YYEOF;
                        break zzForAction;
                    }
                    else {
                        // store back cached positions
                        zzCurrentPos  = zzCurrentPosL;
                        zzMarkedPos   = zzMarkedPosL;
                        boolean eof = zzRefill();
                        // get translated positions and possibly new buffer
                        zzCurrentPosL  = zzCurrentPos;
                        zzMarkedPosL   = zzMarkedPos;
                        zzBufferL      = zzBuffer;
                        zzEndReadL     = zzEndRead;
                        if (eof) {
                            zzInput = YYEOF;
                            break zzForAction;
                        }
                        else {
                            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
                            zzCurrentPosL += Character.charCount(zzInput);
                        }
                    }
                    int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMap(zzInput) ];
                    if (zzNext == -1) break zzForAction;
                    zzState = zzNext;

                    zzAttributes = zzAttrL[zzState];
                    if ( (zzAttributes & 1) == 1 ) {
                        zzAction = zzState;
                        zzMarkedPosL = zzCurrentPosL;
                        if ( (zzAttributes & 8) == 8 ) break zzForAction;
                    }

                }
            }

            // store back cached position
            zzMarkedPos = zzMarkedPosL;

            if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
                zzAtEOF = true;
                zzDoEOF();
                { return new java_cup.runtime.Symbol(sym.EOF); }
            }
            else {
                switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
                    case 1:
                    { ;
                    }
                    // fall through
                    case 64: break;
                    case 2:
                    { return token(sym.NOT, yytext());
                    }
                    // fall through
                    case 65: break;
                    case 3:
                    { yybegin(STRING); string = "" + yytext();
                    }
                    // fall through
                    case 66: break;
                    case 4:
                    { return token(sym.MOD, yytext());
                    }
                    // fall through
                    case 67: break;
                    case 5:
                    { return token(sym.OPENPARENTHESIS, yytext());
                    }
                    // fall through
                    case 68: break;
                    case 6:
                    { return token(sym.CLOSEPARENTHESIS, yytext());
                    }
                    // fall through
                    case 69: break;
                    case 7:
                    { return token(sym.MULTIPLY, yytext());
                    }
                    // fall through
                    case 70: break;
                    case 8:
                    { return token(sym.PLUS, yytext());
                    }
                    // fall through
                    case 71: break;
                    case 9:
                    { return token(sym.COMMA, yytext());
                    }
                    // fall through
                    case 72: break;
                    case 10:
                    { return token(sym.MINUS, yytext());
                    }
                    // fall through
                    case 73: break;
                    case 11:
                    { return token(sym.DOT, yytext());
                    }
                    // fall through
                    case 74: break;
                    case 12:
                    { return token(sym.DIVIDE, yytext());
                    }
                    // fall through
                    case 75: break;
                    case 13:
                    { return token(sym.INTLITERAL, yytext());
                    }
                    // fall through
                    case 76: break;
                    case 14:
                    { return token(sym.SEMICOLON, yytext());
                    }
                    // fall through
                    case 77: break;
                    case 15:
                    { return token(sym.LESS, yytext());
                    }
                    // fall through
                    case 78: break;
                    case 16:
                    { return token(sym.ASSIGN, yytext());
                    }
                    // fall through
                    case 79: break;
                    case 17:
                    { return token(sym.GREATER, yytext());
                    }
                    // fall through
                    case 80: break;
                    case 18:
                    { return token(sym.IDENTIFIER, yytext());
                    }
                    // fall through
                    case 81: break;
                    case 19:
                    { return token(sym.OPENBRACKET, yytext());
                    }
                    // fall through
                    case 82: break;
                    case 20:
                    { return token(sym.CLOSEBRACKET, yytext());
                    }
                    // fall through
                    case 83: break;
                    case 21:
                    { return token(sym.OPENCURLYBRACES, yytext());
                    }
                    // fall through
                    case 84: break;
                    case 22:
                    { return token(sym.CLOSECURLYBRACES, yytext());
                    }
                    // fall through
                    case 85: break;
                    case 23:
                    { string = string + yytext();
                    }
                    // fall through
                    case 86: break;
                    case 24:
                    { yybegin(YYINITIAL);
                        return token(sym.STRINGLITERAL, string + yytext());
                    }
                    // fall through
                    case 87: break;
                    case 25:
                    { return token(sym.NOTEQUAL, yytext());
                    }
                    // fall through
                    case 88: break;
                    case 26:
                    { return token(sym.AND, yytext());
                    }
                    // fall through
                    case 89: break;
                    case 27:
                    { return token(sym.DOUBLELITERAL, yytext());
                    }
                    // fall through
                    case 90: break;
                    case 28:
                    { return token(sym.LESSEQUAL, yytext());
                    }
                    // fall through
                    case 91: break;
                    case 29:
                    { return token(sym.EQUAL, yytext());
                    }
                    // fall through
                    case 92: break;
                    case 30:
                    { return token(sym.GREATEREQUAL, yytext());
                    }
                    // fall through
                    case 93: break;
                    case 31:
                    { return token(sym.OPENCLOSEBRACKET, yytext());
                    }
                    // fall through
                    case 94: break;
                    case 32:
                    { return token(sym.IF, yytext());
                    }
                    // fall through
                    case 95: break;
                    case 33:
                    { return token(sym.OR, yytext());
                    }
                    // fall through
                    case 96: break;
                    case 34:
                    { return token(sym.FOR, yytext());
                    }
                    // fall through
                    case 97: break;
                    case 35:
                    { return token(sym.INT, yytext());
                    }
                    // fall through
                    case 98: break;
                    case 36:
                    { return token(sym.NEW, yytext());
                    }
                    // fall through
                    case 99: break;
                    case 37:
                    { return token(sym.BOOL, yytext());
                    }
                    // fall through
                    case 100: break;
                    case 38:
                    { return token(sym.BTOI, yytext());
                    }
                    // fall through
                    case 101: break;
                    case 39:
                    { return token(sym.DTOI, yytext());
                    }
                    // fall through
                    case 102: break;
                    case 40:
                    { return token(sym.ELSE, yytext());
                    }
                    // fall through
                    case 103: break;
                    case 41:
                    { return token(sym.ITOB, yytext());
                    }
                    // fall through
                    case 104: break;
                    case 42:
                    { return token(sym.ITOD, yytext());
                    }
                    // fall through
                    case 105: break;
                    case 43:
                    { return token(sym.NULL, yytext());
                    }
                    // fall through
                    case 106: break;
                    case 44:
                    { return token(sym.THIS, yytext());
                    }
                    // fall through
                    case 107: break;
                    case 45:
                    { return token(sym.BOOLEANLITERAL, yytext());
                    }
                    // fall through
                    case 108: break;
                    case 46:
                    { return token(sym.VOID, yytext());
                    }
                    // fall through
                    case 109: break;
                    case 47:
                    { return token(sym.PRINT, yytext());
                    }
                    // fall through
                    case 110: break;
                    case 48:
                    { return token(sym.BREAK, yytext());
                    }
                    // fall through
                    case 111: break;
                    case 49:
                    { return token(sym.CLASS, yytext());
                    }
                    // fall through
                    case 112: break;
                    case 50:
                    { return token(sym.WHILE, yytext());
                    }
                    // fall through
                    case 113: break;
                    case 51:
                    { return token(sym.DOUBLE, yytext());
                    }
                    // fall through
                    case 114: break;
                    case 52:
                    { return token(sym.PUBLIC, yytext());
                    }
                    // fall through
                    case 115: break;
                    case 53:
                    { return token(sym.RETURN, yytext());
                    }
                    // fall through
                    case 116: break;
                    case 54:
                    { return token(sym.STRING, yytext());
                    }
                    // fall through
                    case 117: break;
                    case 55:
                    { return token(sym.EXTENDS, yytext());
                    }
                    // fall through
                    case 118: break;
                    case 56:
                    { return token(sym.PRIVATE, yytext());
                    }
                    // fall through
                    case 119: break;
                    case 57:
                    { return token(sym.NEWARRAY, yytext());
                    }
                    // fall through
                    case 120: break;
                    case 58:
                    { return token(sym.READLINE, yytext());
                    }
                    // fall through
                    case 121: break;
                    case 59:
                    { return token(sym.CONTINUE, yytext());
                    }
                    // fall through
                    case 122: break;
                    case 60:
                    { return token(sym.INTERFACE, yytext());
                    }
                    // fall through
                    case 123: break;
                    case 61:
                    { return token(sym.PROTECTED, yytext());
                    }
                    // fall through
                    case 124: break;
                    case 62:
                    { return token(sym.IMPLEMENTS, yytext());
                    }
                    // fall through
                    case 125: break;
                    case 63:
                    { return token(sym.READINTEGER, yytext());
                    }
                    // fall through
                    case 126: break;
                    default:
                        zzScanError(ZZ_NO_MATCH);
                }
            }
        }
    }


}

